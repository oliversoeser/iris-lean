{"name":"Lean.Meta.Tactic.Grind.ProveEq","instances":[],"imports":["Lean.Meta.Tactic.Grind.Types","Lean.Meta.Tactic.Grind.Simp"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/ProveEq.lean#L223-L236","name":"Lean.Meta.Grind.proveHEq?","line":223,"kind":"def","docLink":"./Lean/Meta/Tactic/Grind/ProveEq.html#Lean.Meta.Grind.proveHEq?","doc":"Similar to `proveEq?`, but for heterogeneous equality. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/ProveEq.html#Lean.Meta.Grind.proveHEq?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">proveHEq?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM\">GoalM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/ProveEq.lean#L212-L221","name":"Lean.Meta.Grind.proveEq?.tryAbstract","line":212,"kind":"def","docLink":"./Lean/Meta/Tactic/Grind/ProveEq.html#Lean.Meta.Grind.proveEq?.tryAbstract","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/ProveEq.html#Lean.Meta.Grind.proveEq?.tryAbstract\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">proveEq?</span>.<span class=\"name\">tryAbstract</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs₀ </span><span class=\"fn\">rhs₀</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM\">GoalM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/ProveEq.lean#L175-L221","name":"Lean.Meta.Grind.proveEq?","line":175,"kind":"def","docLink":"./Lean/Meta/Tactic/Grind/ProveEq.html#Lean.Meta.Grind.proveEq?","doc":"Try to construct a proof that `lhs = rhs` using the information in the\ngoal state. If `lhs` and `rhs` have not been internalized, this function\nwill internalize then, process propagated equalities, and then check\nwhether they are in the same equivalence class or not.\nThe goal state is not modified by this function.\nThis function mainly relies on congruence closure, and constraint\npropagation. It will not perform case analysis.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/ProveEq.html#Lean.Meta.Grind.proveEq?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">proveEq?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">abstract</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM\">GoalM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/ProveEq.lean#L11-L16","name":"Lean.Meta.Grind.preprocessLight","line":11,"kind":"def","docLink":"./Lean/Meta/Tactic/Grind/ProveEq.html#Lean.Meta.Grind.preprocessLight","doc":"A lighter version of `preprocess` which produces a definitionally equal term,\nbut ensures assumptions made by `grind` are satisfied.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/ProveEq.html#Lean.Meta.Grind.preprocessLight\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">preprocessLight</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM\">GoalM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>"}]}