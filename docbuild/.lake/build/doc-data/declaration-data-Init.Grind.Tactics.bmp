{"name":"Init.Grind.Tactics","instances":[{"typeNames":["Lean.Grind.Config"],"name":"Lean.Grind.instInhabitedConfig","className":"Inhabited"},{"typeNames":["Lean.Grind.Config"],"name":"Lean.Grind.instBEqConfig","className":"BEq"}],"imports":["Init.Tactics"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L207-L210","name":"Lean.Parser.Tactic.grindTrace","line":207,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindTrace","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">grindTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L201-L204","name":"Lean.Parser.Tactic.grind","line":201,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grind","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grind\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">grind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L199-L199","name":"Lean.Parser.Tactic.grindParam","line":199,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindParam","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindParam\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">grindParam</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L198-L198","name":"Lean.Parser.Tactic.grindLemma","line":198,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindLemma","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindLemma\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">grindLemma</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L197-L197","name":"Lean.Parser.Tactic.grindErase","line":197,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindErase","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindErase\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">grindErase</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L187-L187","name":"Lean.Grind.instBEqConfig","line":187,"kind":"instance","docLink":"./Init/Grind/Tactics.html#Lean.Grind.instBEqConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.instBEqConfig\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">instBEqConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L187-L187","name":"Lean.Grind.instInhabitedConfig","line":187,"kind":"instance","docLink":"./Init/Grind/Tactics.html#Lean.Grind.instInhabitedConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.instInhabitedConfig\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">instInhabitedConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L186-L186","name":"Lean.Grind.Config.ringNull","line":186,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.ringNull","doc":"When `true` (default: `false`), the commutative ring procedure in `grind` constructs stepwise\nproof terms, instead of a single-step Nullstellensatz certificate\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.ringNull\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">ringNull</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L181-L181","name":"Lean.Grind.Config.ringSteps","line":181,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.ringSteps","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.ringSteps\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">ringSteps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L180-L180","name":"Lean.Grind.Config.ring","line":180,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.ring","doc":"When `true` (default: `false`), uses procedure for handling equalities over commutative rings.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.ring\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">ring</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L176-L176","name":"Lean.Grind.Config.zeta","line":176,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.zeta","doc":"When `true` (default: `true`), performs zeta reduction of let expressions during normalization.\nThat is, `let x := v; e[x]` reduces to `e[v]`. See also `zetaDelta`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.zeta\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">zeta</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L171-L171","name":"Lean.Grind.Config.zetaDelta","line":171,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.zetaDelta","doc":"When set to `true` (default: `true`), local definitions are unfolded during normalization and internalization.\nIn other words, given a local context with an entry `x : t := e`, the free variable `x` is reduced to `e`.\nNote that this behavior is also available in `simp`, but there its default is `false` because `simp` is not\nalways used as a terminal tactic, and it important to preserve the abstractions introduced by users.\nAdditionally, in `grind` we observed that `zetaDelta` is particularly important when combined with function induction.\nIn such scenarios, the same let-expressions can be introduced by function induction and also by unfolding the\ncorresponding definition. We want to avoid a situation in which `zetaDelta` is not applied to let-declarations\nintroduced by function induction while `zeta` unfolds the definition, causing a mismatch.\nFinally, note that congruence closure is less effective on terms containing many binders such as\n`lambda` and `let` expressions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.zetaDelta\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">zetaDelta</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L158-L158","name":"Lean.Grind.Config.mbtc","line":158,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.mbtc","doc":"If `mbtc` is `true`, `grind` will use model-based theory combination for creating new case splits.\nSee paper \"Model-based Theory Combination\" for details.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.mbtc\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">mbtc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L153-L153","name":"Lean.Grind.Config.qlia","line":153,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.qlia","doc":"If `qlia` is `true`, `grind` may generate counterexamples for integer constraints\nusing rational numbers, and ignoring divisibility constraints.\nThis approach is cheaper but incomplete. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.qlia\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">qlia</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L148-L148","name":"Lean.Grind.Config.clean","line":148,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.clean","doc":"If `clean` is `true`, `grind` uses `expose_names` and only generates accessible names. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.clean\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">clean</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L146-L146","name":"Lean.Grind.Config.verbose","line":146,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.verbose","doc":"If `verbose` is `false`, additional diagnostics information is not collected. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.verbose\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">verbose</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L144-L144","name":"Lean.Grind.Config.lookahead","line":144,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.lookahead","doc":"TODO "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.lookahead\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">lookahead</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L142-L142","name":"Lean.Grind.Config.funext","line":142,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.funext","doc":"If `funext` is `true`, `grind` creates new opportunities for applying function extensionality by case-splitting\non equalities between lambda expressions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.funext\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">funext</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L137-L137","name":"Lean.Grind.Config.etaStruct","line":137,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.etaStruct","doc":"If `etaStruct` is `true`, then for each term `t : S` such that `S` is a structure,\nand is tagged with `[grind ext]`, `grind` adds the equation `t = ⟨t.1, ..., t.n⟩`\nwhich holds by reflexivity. Moreover, the extensionality theorem for `S` is not used.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.etaStruct\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">etaStruct</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L131-L131","name":"Lean.Grind.Config.extAll","line":131,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.extAll","doc":"If `extAll` is `true`, `grind` uses any extensionality theorems available in the environment. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.extAll\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">extAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L129-L129","name":"Lean.Grind.Config.ext","line":129,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.ext","doc":"If `ext` is `true`, `grind` uses extensionality theorems that have been marked with `[grind ext]`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.ext\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">ext</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L127-L127","name":"Lean.Grind.Config.canonHeartbeats","line":127,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.canonHeartbeats","doc":"Maximum number of heartbeats (in thousands) the canonicalizer can spend per definitional equality test. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.canonHeartbeats\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">canonHeartbeats</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L125-L125","name":"Lean.Grind.Config.splitImp","line":125,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.splitImp","doc":"If `splitImp` is `true`, then given an implication `p → q` or `(h : p) → q h`, `grind` splits on `p`\nif the implication is true. Otherwise, it will split only if `p` is an arithmetic predicate.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.splitImp\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">splitImp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L120-L120","name":"Lean.Grind.Config.splitIndPred","line":120,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.splitIndPred","doc":"If `splitIndPred` is `true`, `grind` performs case-splitting on inductive predicates.\nOtherwise, it performs case-splitting only on types marked with `[grind cases]` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.splitIndPred\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">splitIndPred</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L116-L116","name":"Lean.Grind.Config.splitIte","line":116,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.splitIte","doc":"If `splitIte` is `true`, `grind` performs case-splitting on `if-then-else` expressions during the search. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.splitIte\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">splitIte</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L114-L114","name":"Lean.Grind.Config.splitMatch","line":114,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.splitMatch","doc":"If `splitMatch` is `true`, `grind` performs case-splitting on `match`-expressions during the search. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.splitMatch\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">splitMatch</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L112-L112","name":"Lean.Grind.Config.matchEqs","line":112,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.matchEqs","doc":"If `matchEqs` is `true`, `grind` uses `match`-equations as E-matching theorems. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.matchEqs\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">matchEqs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L110-L110","name":"Lean.Grind.Config.instances","line":110,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.instances","doc":"Maximum number of theorem instances generated using E-matching in a proof search tree branch. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.instances\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">instances</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L108-L108","name":"Lean.Grind.Config.gen","line":108,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.gen","doc":"Maximum term generation.\nThe input goal terms have generation 0. When we instantiate a theorem using a term from generation `n`,\nthe new terms have generation `n+1`. Thus, this parameter limits the length of an instantiation chain. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.gen\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">gen</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L103-L103","name":"Lean.Grind.Config.ematch","line":103,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.ematch","doc":"Maximum number of E-matching (aka heuristic theorem instantiation) rounds before each case split. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.ematch\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">ematch</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L101-L101","name":"Lean.Grind.Config.splits","line":101,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.splits","doc":"Maximum number of case-splits in a proof search branch. It does not include splits performed during normalization. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.splits\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">splits</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L99-L99","name":"Lean.Grind.Config.trace","line":99,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.trace","doc":"If `trace` is `true`, `grind` records used E-matching theorems and case-splits. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.trace\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">trace</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L97-L97","name":"Lean.Grind.Config.mk","line":97,"kind":"ctor","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">trace</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">splits </span><span class=\"fn\">ematch </span><span class=\"fn\">gen </span><span class=\"fn\">instances</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matchEqs </span><span class=\"fn\">splitMatch </span><span class=\"fn\">splitIte </span><span class=\"fn\">splitIndPred </span><span class=\"fn\">splitImp</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">canonHeartbeats</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ext </span><span class=\"fn\">extAll </span><span class=\"fn\">etaStruct </span><span class=\"fn\">funext </span><span class=\"fn\">lookahead </span><span class=\"fn\">verbose </span><span class=\"fn\">clean </span><span class=\"fn\">qlia </span><span class=\"fn\">mbtc </span><span class=\"fn\">zetaDelta </span><span class=\"fn\">zeta </span><span class=\"fn\">ring</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ringSteps</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ringNull</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L93-L187","name":"Lean.Grind.Config","line":93,"kind":"structure","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config","doc":"The configuration for `grind`.\nPassed to `grind` using, for example, the `grind (config := { matchEqs := true })` syntax.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L88-L88","name":"Lean.Parser.Attr.grind?","line":88,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grind?","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grind?\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grind?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L87-L87","name":"Lean.Parser.Attr.grind","line":87,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grind","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grind\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L83-L86","name":"Lean.Parser.Attr.grindMod","line":83,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindMod","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindMod\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindMod</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L82-L82","name":"Lean.Parser.Attr.grindExt","line":82,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindExt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindExt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindExt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L81-L81","name":"Lean.Parser.Attr.grindIntro","line":81,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindIntro","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindIntro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindIntro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L80-L80","name":"Lean.Parser.Attr.grindCasesEager","line":80,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindCasesEager","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindCasesEager\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindCasesEager</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L79-L79","name":"Lean.Parser.Attr.grindCases","line":79,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindCases","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindCases\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindCases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L78-L78","name":"Lean.Parser.Attr.grindUsr","line":78,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindUsr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindUsr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindUsr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L77-L77","name":"Lean.Parser.Attr.grindLR","line":77,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindLR","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindLR\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindLR</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L76-L76","name":"Lean.Parser.Attr.grindRL","line":76,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindRL","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindRL\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindRL</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L75-L75","name":"Lean.Parser.Attr.grindFwd","line":75,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindFwd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindFwd\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindFwd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L74-L74","name":"Lean.Parser.Attr.grindBwd","line":74,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindBwd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindBwd\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindBwd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L73-L73","name":"Lean.Parser.Attr.grindEqBwd","line":73,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindEqBwd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindEqBwd\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindEqBwd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L72-L72","name":"Lean.Parser.Attr.grindEqRhs","line":72,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindEqRhs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindEqRhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindEqRhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L71-L71","name":"Lean.Parser.Attr.grindEqBoth","line":71,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindEqBoth","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindEqBoth\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindEqBoth</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L70-L70","name":"Lean.Parser.Attr.grindEq","line":70,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindEq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindEq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindEq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L69-L69","name":"Lean.Parser.Attr.grindGen","line":69,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindGen","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Attr.grindGen\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindGen</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L63-L66","name":"Lean.Parser.resetGrindAttrs","line":63,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.resetGrindAttrs","doc":"Reset all `grind` attributes. This command is intended for testing purposes only and should not be used in applications.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.resetGrindAttrs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">resetGrindAttrs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L58-L59","name":"Lean.Grind.genHEqPattern","line":58,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.genHEqPattern","doc":"Similar to `genPattern` but for the heterogenous case "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.genHEqPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">genHEqPattern</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_h</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_val</span> : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L12-L56","name":"Lean.Grind.genPattern","line":12,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.genPattern","doc":"Gadget for representing generalization steps `h : x = val` in patterns\nThis gadget is used to represent patterns in theorems that have been generalized to reduce the\nnumber of casts introduced during E-matching based instantiation.\n\nFor example, consider the theorem\n```\nOption.pbind_some {α1 : Type u_1} {a : α1} {α2 : Type u_2}\n    {f : (a_1 : α1) → some a = some a_1 → Option α2}\n    : (some a).pbind f = f a rfl\n```\nNow, suppose we have a goal containing the term `c.pbind g` and the equivalence class\n`{c, some b}`. The E-matching module generates the instance\n```\n(some b).pbind (cast ⋯ g)\n```\nThe `cast` is necessary because `g`'s type contains `c` instead of `some b.\nThis `cast` problematic because we don't have a systematic way of pushing casts over functions\nto its arguments. Moreover, heterogeneous equality is not effective because the following theorem\nis not provable in DTT:\n```\ntheorem hcongr (h₁ : f ≍ g) (h₂ : a ≍ b)  : f a ≍ g b := ...\n```\nThe standard solution is to generalize the theorem above and write it as\n```\ntheorem Option.pbind_some'\n        {α1 : Type u_1} {a : α1} {α2 : Type u_2}\n        {x : Option α1}\n        {f : (a_1 : α1) → x = some a_1 → Option α2}\n        (h : x = some a)\n        : x.pbind f = f a h := by\n  subst h\n  apply Option.pbind_some\n```\nInternally, we use this gadget to mark the E-matching pattern as\n```\n(genPattern h x (some a)).pbind f\n```\nThis pattern is matched in the same way we match `(some a).pbind f`, but it saves the proof\nfor the actual term to the `some`-application in `f`, and the actual term in `x`.\n\nIn the example above, `c.pbind g` also matches the pattern `(genPattern h x (some a)).pbind f`,\nand stores `c` in `x`, `b` in `a`, and the proof that `c = some b` in `h`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.genPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">genPattern</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_h</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">_val</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"}]}