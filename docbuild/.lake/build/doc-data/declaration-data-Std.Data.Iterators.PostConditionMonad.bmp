{"name":"Std.Data.Iterators.PostConditionMonad","instances":[{"typeNames":["Std.Iterators.PostconditionT"],"name":"Std.Iterators.instFunctorPostconditionT","className":"Functor"},{"typeNames":["Std.Iterators.PostconditionT"],"name":"Std.Iterators.instMonadPostconditionT","className":"Monad"}],"imports":["Init.Control.Lawful.Basic","Init.Data.Subtype","Init.PropLemmas"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L174-L177","name":"Std.Iterators.PostconditionT.operation_lift","line":174,"kind":"theorem","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.operation_lift","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.operation_lift\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">operation_lift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Functor\">Functor</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.lift\">lift</a> <span class=\"fn\">x</span>)</span>.<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.operation\">operation</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(fun (<span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <a href=\"./Init/Prelude.html#Subtype.mk\">⟨</a><span class=\"fn\">x_1</span>, <a href=\"./Init/Prelude.html#True.intro\">True.intro</a><a href=\"./Init/Prelude.html#Subtype.mk\">⟩</a>)</span> <a href=\"./Init/Prelude.html#Functor.map\">&lt;$&gt;</a> <span class=\"fn\">x</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L168-L172","name":"Std.Iterators.PostconditionT.operation_map","line":168,"kind":"theorem","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.operation_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.operation_map\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">operation_map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Functor\">Functor</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.map\">PostconditionT.map</a> <span class=\"fn\">f</span> <span class=\"fn\">x</span>)</span>.<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.operation\">operation</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(fun (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.Property\">Property</a></span></span>) =&gt; <a href=\"./Init/Prelude.html#Subtype.mk\">⟨</a><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\"><span class=\"fn\">a</span>.<a href=\"./Init/Prelude.html#Subtype.val\">val</a></span></span>, <span class=\"fn\">⋯</span><a href=\"./Init/Prelude.html#Subtype.mk\">⟩</a>)</span> <a href=\"./Init/Prelude.html#Functor.map\">&lt;$&gt;</a> <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.operation\">operation</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L157-L166","name":"Std.Iterators.PostconditionT.property_map","line":157,"kind":"theorem","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.property_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.property_map\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">property_map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Functor\">Functor</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">β</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.map\">PostconditionT.map</a> <span class=\"fn\">f</span> <span class=\"fn\">x</span>)</span>.<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.Property\">Property</a></span> <span class=\"fn\">b</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <a href=\"./Init/Core.html#Exists\">∃</a> <a href=\"./Init/Core.html#Exists\">(</a><span class=\"fn\">a</span> <a href=\"./Init/Core.html#Exists\">:</a> <span class=\"fn\">α</span><a href=\"./Init/Core.html#Exists\">)</a><a href=\"./Init/Core.html#Exists\">,</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.Property\">Property</a></span> <span class=\"fn\">a</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L142-L155","name":"Std.Iterators.PostconditionT.map_pure","line":142,"kind":"theorem","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.map_pure","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.map_pure\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">map_pure</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Lawful/Basic.html#LawfulMonad\">LawfulMonad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.map\">PostconditionT.map</a> <span class=\"fn\">f</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">a</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L123-L127","name":"Std.Iterators.PostconditionT.property_pure","line":123,"kind":"theorem","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.property_pure","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.property_pure\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">property_pure</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">x</span>)</span>.<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.Property\">Property</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">fun (<span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x_1</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L117-L121","name":"Std.Iterators.PostconditionT.computation_pure","line":117,"kind":"theorem","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.computation_pure","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.computation_pure\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">computation_pure</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">x</span>)</span>.<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.operation\">operation</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Init/Prelude.html#Subtype.mk\">⟨</a><span class=\"fn\">x</span>, <span class=\"fn\">⋯</span><a href=\"./Init/Prelude.html#Subtype.mk\">⟩</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L112-L115","name":"Std.Iterators.instMonadPostconditionT","line":112,"kind":"instance","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.instMonadPostconditionT","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.instMonadPostconditionT\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">instMonadPostconditionT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">(<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L109-L110","name":"Std.Iterators.instFunctorPostconditionT","line":109,"kind":"instance","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.instFunctorPostconditionT","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.instFunctorPostconditionT\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">instFunctorPostconditionT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Functor\">Functor</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Functor\">Functor</a> <span class=\"fn\">(<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L101-L107","name":"Std.Iterators.PostconditionT.run","line":101,"kind":"def","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.run","doc":"Converts an operation from `PostConditionT m` to `m`, discarding the postcondition.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.run\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">run</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L93-L99","name":"Std.Iterators.PostconditionT.liftMap","line":93,"kind":"def","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.liftMap","doc":"Lifts an operation from `m` to `PostConditionT m` and then applies `PostconditionT.map`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.liftMap\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">liftMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L84-L91","name":"Std.Iterators.PostconditionT.pbind","line":84,"kind":"def","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.pbind","doc":"A version of `bind` that provides a proof of the previous postcondition to the mapping function.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.pbind\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">pbind</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.Property\">Property</a></span></span> → <span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L72-L82","name":"Std.Iterators.PostconditionT.bind","line":72,"kind":"def","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.bind","doc":"Given a function `α → PostconditionT m β`, returns a a function\n`PostconditionT m α → PostconditionT m β`, turning `PostconditionT m` into a monad.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.bind\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">bind</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L59-L70","name":"Std.Iterators.PostconditionT.map","line":59,"kind":"def","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.map","doc":"Given a function `f : α → β`, returns a a function `PostconditionT m α → PostconditionT m β`,\nturning `PostconditionT m` into a functor.\n\nThe postcondition of the `x.map f` states that the return value is the image under `f` of some\n`a : α` satisfying the `x.Property`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.map\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Functor\">Functor</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L51-L57","name":"Std.Iterators.PostconditionT.liftWithProperty","line":51,"kind":"def","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.liftWithProperty","doc":"Lifts a monadic value from `m { a : α // P a }` to a value `PostconditionT m α`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.liftWithProperty\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">liftWithProperty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">P</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Subtype\">{</a> <span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Subtype\">:</a> <span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Subtype\">//</a> <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Subtype\">}</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L39-L49","name":"Std.Iterators.PostconditionT.lift","line":39,"kind":"def","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.lift","doc":"Lifts an operation from `m` to `PostconditionT m` without asserting any nontrivial postcondition.\n\nCaution: `lift` is not a lawful lift function.\nFor example, `pure a : PostconditionT m α` is not the same as\n`PostconditionT.lift (pure a : m α)`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.lift\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">lift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Functor\">Functor</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L37-L37","name":"Std.Iterators.PostconditionT.operation","line":37,"kind":"def","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.operation","doc":"The actual monadic operation. Its return value is bundled together with a proof that\nit satisfies `Property`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.operation\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">operation</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.Property\">Property</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L31-L31","name":"Std.Iterators.PostconditionT.Property","line":31,"kind":"def","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.Property","doc":"A predicate that holds for the return value(s) of the `m`-monadic operation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.Property\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">Property</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L27-L27","name":"Std.Iterators.PostconditionT.mk","line":27,"kind":"ctor","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Property</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">operation</span> : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\">Property</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\">PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Iterators/PostConditionMonad.lean#L13-L37","name":"Std.Iterators.PostconditionT","line":13,"kind":"structure","docLink":"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT","doc":"`PostconditionT m α` represents an operation in the monad `m` together with a\nintrinsic proof that some postcondition holds for the `α` valued monadic result.\nIt consists of a predicate `P` about `α` and an element of `m ({ a // P a })` and is a helpful tool\nfor intrinsic verification, notably termination proofs, in the context of iterators.\n\n`PostconditionT m` is a monad if `m` is. However, note that `PostconditionT m α` is a structure,\nso that the compiler will generate inefficient code from recursive functions returning\n`PostconditionT m α`. Optimizations for `ReaderT`, `StateT` etc. aren't applicable for structures.\n\nMoreover, `PostconditionT m α` is not a well-behaved monad transformer because `PostconditionT.lift`\nneither commutes with `pure` nor with `bind`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Iterators/PostConditionMonad.html#Std.Iterators.PostconditionT\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">PostconditionT</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max w w')</div></div>"}]}