<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="icon" href="../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Meta.Tactic.Grind.Types</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Lean.Meta.Tactic.Grind.Types";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Tactic</span>.<span class="name">Grind</span>.<span class="name">Types</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Lean/HeadIndex.html">Lean.HeadIndex</a></li><li><a href="../../../.././Init/Data/Queue.html">Init.Data.Queue</a></li><li><a href="../../../.././Init/Grind/Tactics.html">Init.Grind.Tactics</a></li><li><a href="../../../.././Lean/Meta/AbstractNestedProofs.html">Lean.Meta.AbstractNestedProofs</a></li><li><a href="../../../.././Lean/Meta/Basic.html">Lean.Meta.Basic</a></li><li><a href="../../../.././Lean/Meta/CongrTheorems.html">Lean.Meta.CongrTheorems</a></li><li><a href="../../../.././Std/Data/TreeSet.html">Std.Data.TreeSet</a></li><li><a href="../../../.././Lean/Meta/Tactic/Ext.html">Lean.Meta.Tactic.Ext</a></li><li><a href="../../../.././Lean/Meta/Tactic/Util.html">Lean.Meta.Tactic.Util</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/AlphaShareCommon.html">Lean.Meta.Tactic.Grind.AlphaShareCommon</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/Attr.html">Lean.Meta.Tactic.Grind.Attr</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/Cases.html">Lean.Meta.Tactic.Grind.Cases</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html">Lean.Meta.Tactic.Grind.EMatchTheorem</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html">Lean.Meta.Tactic.Grind.ENodeKey</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/ExtAttr.html">Lean.Meta.Tactic.Grind.ExtAttr</a></li><li><a href="../../../.././Lean/Meta/Tactic/Simp/Types.html">Lean.Meta.Tactic.Simp.Types</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/Arith/Types.html">Lean.Meta.Tactic.Grind.Arith.Types</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Meta.Tactic.Grind.Types" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.congrPlaceholderProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">congrPlaceholderProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isInterpreted"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isInterpreted</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.grind.debug"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">debug</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.grind.debug.proofs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">debug</span>.<span class="name">proofs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.grind.warning"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">warning</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Context"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Context</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.CongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrTheoremCacheKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqCongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCongrTheoremCacheKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashableCongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCongrTheoremCacheKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.EMatchTheoremTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatchTheoremTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqEMatchTheoremTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqEMatchTheoremTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashableEMatchTheoremTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableEMatchTheoremTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Trace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Trace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Counters"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Counters</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedCounters"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCounters</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instNonemptyMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instNonemptyMethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GrindM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GrindM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mapGrindM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mapGrindM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.withoutReportingMVarIssues"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withoutReportingMVarIssues</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getTrueExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getFalseExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getBoolTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getBoolTrueExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getBoolFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getBoolFalseExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getNatZeroExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getNatZeroExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.cheapCasesOnly"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">cheapCasesOnly</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.reportMVarInternalization"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">reportMVarInternalization</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isMatchEqLikeDeclName"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isMatchEqLikeDeclName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.saveEMatchTheorem"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveEMatchTheorem</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.saveCases"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveCases</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getMaxGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMaxGeneration</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.abstractNestedProofs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">abstractNestedProofs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.shareCommon"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">shareCommon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isTrueExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isFalseExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkHCongrWithArity"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkHCongrWithArity</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.reportIssue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">reportIssue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.doElemReportIssue!__"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">doElemReportIssue!__</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instReprENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ENode.isRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span>.<span class="name">isRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ENode.isCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span>.<span class="name">isCongrRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.NewFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">NewFact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ENodeMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENodeMap</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.CongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashableCongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCongrKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqCongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCongrKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.CongrTable"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrTable</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ParentSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentSet</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ParentMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentMap</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.PreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PreInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashablePreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashablePreInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqPreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqPreInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.PreInstanceSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PreInstanceSet</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.NewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">NewRawFact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedNewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedNewRawFact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Canon.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Canon.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.CaseTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CaseTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedCaseTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCaseTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.EMatch.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.EMatch.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashableSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableSplitInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo.beq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">beq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqSplitInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo.getExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">getExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo.lt"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">lt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitArg"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Split.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Split.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Clean.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Clean.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedGoal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedGoal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.hasSameRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">hasSameRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.isCongruent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">isCongruent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.admit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">admit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GoalM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GoalM.runCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">runCore</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GoalM.run"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">run</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GoalM.run'"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">run'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.updateLastTag"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">updateLastTag</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.«doElemTrace_goal[_]__»"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">«doElemTrace_goal[_]__»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.markTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markTheoremInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.addNewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addNewRawFact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.addTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addTheoremInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.checkMaxInstancesExceeded"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxInstancesExceeded</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.checkMaxCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxCaseSplit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.checkMaxEmatchExceeded"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxEmatchExceeded</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getENode?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getENode?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.throwNonInternalizedExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">throwNonInternalizedExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getGeneration</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqTrue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqBoolTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqBoolTrue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqBoolFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqBoolFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqv"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqv</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getRoot?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getRoot?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getRoot?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRoot?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getRootENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRootENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getRootENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRootENode?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getNext?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getNext?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getNext"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getNext</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getNext"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getNext</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.alreadyInternalized"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">alreadyInternalized</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getTarget?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getTarget?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getTarget?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getTarget?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqCore</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.hasSameType"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">hasSameType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqHEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqHEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushHEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushHEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqTrue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqBoolTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqBoolTrue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqBoolFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqBoolFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.registerParent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">registerParent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getParents"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getParents</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.resetParentsOf"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">resetParentsOf</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.copyParentsTo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">copyParentsTo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkENodeCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkENodeCore</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.setENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">setENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Offset.processNewEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Offset</span>.<span class="name">processNewEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isNatNum"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isNatNum</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.markAsOffsetTerm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markAsOffsetTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.processNewEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">processNewEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.processNewDiseq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">processNewDiseq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isNonnegIntNum"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isNonnegIntNum</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isIntNum"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isIntNum</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isNum"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isNum</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.hasType"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">hasType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.forEachDiseq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachDiseq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.propagateCutsatDiseq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateCutsatDiseq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.propagateCutsatDiseq.get?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateCutsatDiseq</span>.<span class="name">get?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.propagateCutsatDiseqs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateCutsatDiseqs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.markAsCutsatTerm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markAsCutsatTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.CommRing.processNewEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">CommRing</span>.<span class="name">processNewEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.CommRing.processNewDiseq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">CommRing</span>.<span class="name">processNewDiseq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.propagateCommRingDiseq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateCommRingDiseq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.propagateCommRingDiseq.get?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateCommRingDiseq</span>.<span class="name">get?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.propagateCommRingDiseqs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateCommRingDiseqs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.markAsCommRingTerm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markAsCommRingTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isCongrRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getCongrRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isInconsistent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isInconsistent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkHEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkHEqProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.internalize"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">internalize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.processNewFacts"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">processNewFacts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqHEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqHEqProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqTrueProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqTrueProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqFalseProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqFalseProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqBoolTrueProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqBoolTrueProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqBoolFalseProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqBoolFalseProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.markAsInconsistent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markAsInconsistent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.assignFalseProof"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">assignFalseProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.closeGoal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">closeGoal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getExprs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getExprs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.traverseEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">traverseEqc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.foldEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">foldEqc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.forEachENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.filterENodes"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">filterENodes</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.forEachEqcRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachEqcRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Propagator"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Propagator</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Fallback"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Methods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Methods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Methods.toMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Methods</span>.<span class="name">toMethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.propagateUp"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateUp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.propagateDown"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateDown</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.applyFallback"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">applyFallback</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getEqc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getEqc.go"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getEqc</span>.<span class="name">go</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getEqc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getEqcs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getEqcs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getEqcs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getEqcs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isKnownCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isKnownCaseSplit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isResolvedCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isResolvedCaseSplit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.markCaseSplitAsResolved"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markCaseSplitAsResolved</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.addSplitCandidate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addSplitCandidate</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getExtTheorems"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getExtTheorems</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.synthesizeInstanceAndAssign"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">synthesizeInstanceAndAssign</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.addLookaheadCandidate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addLookaheadCandidate</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.withoutModifyingState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withoutModifyingState</span></a></div></nav><main>
<div class="decl" id="Lean.Meta.Grind.congrPlaceholderProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L27-L28">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.congrPlaceholderProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">congrPlaceholderProof</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></div><p>We use this auxiliary constant to mark delayed congruence proofs.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.congrPlaceholderProof">Lean.Meta.Grind.congrPlaceholderProof</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.mkConst">Lean.mkConst</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Lean.Name.mkSimple">Lean.Name.mkSimple</a> <span class="fn">&quot;[congruence]&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.congrPlaceholderProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isInterpreted"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L30-L36">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isInterpreted"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isInterpreted</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is <code><a href="../../../.././Init/Prelude.html#True">True</a></code>, <code><a href="../../../.././Init/Prelude.html#False">False</a></code>, or a literal value.
See <code><a href="../../../.././Lean/Meta/LitValues.html">Lean.Meta.LitValues</a></code> for supported literals.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isInterpreted">Lean.Meta.Grind.isInterpreted</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><span class="fn">e</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.isTrue">isTrue</a></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.isFalse">isFalse</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>
  <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">do
    let <span class="fn">y</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span>
    <span class="fn"><span class="fn">(fun (<span class="fn">y</span> : <a href="../../../.././Init/Prelude.html#PUnit">PUnit</a>) =&gt; <span class="fn"><a href="../../../.././Lean/Meta/LitValues.html#Lean.Meta.isLitValue">Lean.Meta.isLitValue</a> <span class="fn">e</span></span>)</span> <span class="fn">y</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isInterpreted" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.grind.debug"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L38-L42">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.grind.debug"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">debug</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.grind.debug.proofs"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L44-L48">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.grind.debug.proofs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">debug</span>.<span class="name">proofs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.grind.warning"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L50-L54">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.grind.warning"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">warning</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.Context"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L56-L76">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Context</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Context for <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a></code> monad.</p><ul class="structure_fields" id="Lean.Meta.Grind.Context.mk"><li id="Lean.Meta.Grind.Context.simp" class="structure_field"><div class="structure_field_info">simp : <a href="../../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context">Simp.Context</a></div></li><li id="Lean.Meta.Grind.Context.simpMethods" class="structure_field"><div class="structure_field_info">simpMethods : <a href="../../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Methods">Simp.Methods</a></div></li><li id="Lean.Meta.Grind.Context.config" class="structure_field"><div class="structure_field_info">config : <a href="../../../.././Init/Grind/Tactics.html#Lean.Grind.Config">Grind.Config</a></div></li><li id="Lean.Meta.Grind.Context.cheapCases" class="structure_field"><div class="structure_field_info">cheapCases : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.cheapCases">cheapCases</a></code> is <code>true</code>, <code>grind</code> only applies <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace.cases">cases</a></code> to types that contain
at most one minor premise.
Recall that <code>grind</code> applies <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace.cases">cases</a></code> when introducing types tagged with <code>[grind <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace.cases">cases</a> eager]</code>,
and at <code>Split.lean</code>
Remark: We add this option to implement the <code>lookahead</code> feature, we don't want to create several subgoals
when performing lookahead.</p></div></li><li id="Lean.Meta.Grind.Context.reportMVarIssue" class="structure_field"><div class="structure_field_info">reportMVarIssue : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Context" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.CongrTheoremCacheKey"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L78-L81">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrTheoremCacheKey</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Key for the congruence theorem cache.</p><ul class="structure_fields" id="Lean.Meta.Grind.CongrTheoremCacheKey.mk"><li id="Lean.Meta.Grind.CongrTheoremCacheKey.f" class="structure_field"><div class="structure_field_info">f : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.CongrTheoremCacheKey.numArgs" class="structure_field"><div class="structure_field_info">numArgs : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.CongrTheoremCacheKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqCongrTheoremCacheKey"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L84-L85">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCongrTheoremCacheKey</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">CongrTheoremCacheKey</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCongrTheoremCacheKey">Lean.Meta.Grind.instBEqCongrTheoremCacheKey</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#BEq.mk">{</a>     <span class="fn">beq</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">Lean.Meta.Grind.CongrTheoremCacheKey</a>) =&gt;
      <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></span></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.numArgs">numArgs</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.numArgs">numArgs</a></span></span> <a href="../../../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashableCongrTheoremCacheKey"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L88-L89">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCongrTheoremCacheKey</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">CongrTheoremCacheKey</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCongrTheoremCacheKey">Lean.Meta.Grind.instHashableCongrTheoremCacheKey</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#Hashable.mk">{</a>     <span class="fn">hash</span> := <span class="fn">fun (<span class="fn">a</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">Lean.Meta.Grind.CongrTheoremCacheKey</a>) =&gt;
      <span class="fn"><a href="../../../.././Init/Prelude.html#mixHash">mixHash</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.hashPtrExpr">Lean.Meta.Grind.hashPtrExpr</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></span>)</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.numArgs">numArgs</a></span>)</span></span></span> <a href="../../../.././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.EMatchTheoremTrace"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L91-L94">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatchTheoremTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.Grind.EMatchTheoremTrace.mk"><li id="Lean.Meta.Grind.EMatchTheoremTrace.origin" class="structure_field"><div class="structure_field_info">origin : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Origin">Origin</a></div></li><li id="Lean.Meta.Grind.EMatchTheoremTrace.kind" class="structure_field"><div class="structure_field_info">kind : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremKind">EMatchTheoremKind</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.EMatchTheoremTrace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqEMatchTheoremTrace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L94-L94">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqEMatchTheoremTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqEMatchTheoremTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace">EMatchTheoremTrace</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqEMatchTheoremTrace">Lean.Meta.Grind.instBEqEMatchTheoremTrace</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.beqEMatchTheoremTrace._@.Lean.Meta.Tactic.Grind.Types._hyg.336">Lean.Meta.Grind.beqEMatchTheoremTrace✝</a> <a href="../../../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashableEMatchTheoremTrace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L94-L94">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableEMatchTheoremTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableEMatchTheoremTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace">EMatchTheoremTrace</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableEMatchTheoremTrace">Lean.Meta.Grind.instHashableEMatchTheoremTrace</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Hashable.mk">{</a> <span class="fn">hash</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.hashEMatchTheoremTrace._@.Lean.Meta.Tactic.Grind.Types._hyg.410">Lean.Meta.Grind.hashEMatchTheoremTrace✝</a> <a href="../../../.././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Trace"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L96-L106">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Trace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>E-match theorems and case-splits performed by <code>grind</code>.
Note that it may contain elements that are not needed by the final proof.
For example, <code>grind</code> instantiated the theorem, but theorem instance was not actually used
in the proof.</p><ul class="structure_fields" id="Lean.Meta.Grind.Trace.mk"><li id="Lean.Meta.Grind.Trace.thms" class="structure_field"><div class="structure_field_info">thms : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace">EMatchTheoremTrace</a></span></div></li><li id="Lean.Meta.Grind.Trace.eagerCases" class="structure_field"><div class="structure_field_info">eagerCases : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a></span></div></li><li id="Lean.Meta.Grind.Trace.cases" class="structure_field"><div class="structure_field_info">cases : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Trace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedTrace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L106-L106">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace">Trace</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedTrace">Lean.Meta.Grind.instInhabitedTrace</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace.mk">{</a> <span class="fn">thms</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">eagerCases</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">cases</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace.mk">}</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Counters"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L108-L113">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Counters</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.Grind.Counters.mk"><li id="Lean.Meta.Grind.Counters.thm" class="structure_field"><div class="structure_field_info">thm : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Origin">Origin</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div><div class="structure_field_doc"><p>Number of times E-match theorem has been instantiated.</p></div></li><li id="Lean.Meta.Grind.Counters.case" class="structure_field"><div class="structure_field_info">case : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div><div class="structure_field_doc"><p>Number of times a <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace.cases">cases</a></code> has been performed on an inductive type/predicate</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Counters" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedCounters"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L113-L113">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCounters"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCounters</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters">Counters</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCounters">Lean.Meta.Grind.instInhabitedCounters</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters.mk">{</a> <span class="fn">thm</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">case</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters.mk">}</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L117-L146">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>State for the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a></code> monad.</p><ul class="structure_fields" id="Lean.Meta.Grind.State.mk"><li id="Lean.Meta.Grind.State.scState" class="structure_field"><div class="structure_field_info">scState : <a href="../../../.././Lean/Meta/Tactic/Grind/AlphaShareCommon.html#Lean.Meta.Grind.AlphaShareCommon.State">AlphaShareCommon.State</a></div><div class="structure_field_doc"><p><code>ShareCommon</code> (aka <code>Hashconsing</code>) state.</p></div></li><li id="Lean.Meta.Grind.State.congrThms" class="structure_field"><div class="structure_field_info">congrThms : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">CongrTheoremCacheKey</a> <a href="../../../.././Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem">CongrTheorem</a></span></div><div class="structure_field_doc"><p>Congruence theorems generated so far. Recall that for constant symbols
we rely on the reserved name feature (i.e., <code>mkHCongrWithArityForConst?</code>).
Remark: we currently do not reuse congruence theorems</p></div></li><li id="Lean.Meta.Grind.State.simp" class="structure_field"><div class="structure_field_info">simp : <a href="../../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.State">Simp.State</a></div></li><li id="Lean.Meta.Grind.State.trueExpr" class="structure_field"><div class="structure_field_info">trueExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.State.falseExpr" class="structure_field"><div class="structure_field_info">falseExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.State.natZExpr" class="structure_field"><div class="structure_field_info">natZExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.State.btrueExpr" class="structure_field"><div class="structure_field_info">btrueExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.State.bfalseExpr" class="structure_field"><div class="structure_field_info">bfalseExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.State.lastTag" class="structure_field"><div class="structure_field_info">lastTag : <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a></div><div class="structure_field_doc"><p>Used to generate trace messages of the for <code>[grind] working on &lt;tag&gt;</code>,
and implement the macro <code>trace_goal</code>.</p></div></li><li id="Lean.Meta.Grind.State.issues" class="structure_field"><div class="structure_field_info">issues : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Message.html#Lean.MessageData">MessageData</a></span></div><div class="structure_field_doc"><p>Issues found during the proof search. These issues are reported to
users when <code>grind</code> fails.</p></div></li><li id="Lean.Meta.Grind.State.trace" class="structure_field"><div class="structure_field_info">trace : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace">Trace</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State.trace">trace</a></code> for <code>grind?</code></p></div></li><li id="Lean.Meta.Grind.State.counters" class="structure_field"><div class="structure_field_info">counters : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters">Counters</a></div><div class="structure_field_doc"><p>Performance counters</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instNonemptyMethodsRef"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L150-L150">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instNonemptyMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instNonemptyMethodsRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Nonempty">Nonempty</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.MethodsRef">Lean.Meta.Grind.MethodsRef✝</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.GrindM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L152-L152">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GrindM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.MethodsRef">Lean.Meta.Grind.MethodsRef✝</a>
    <span class="fn">(<a href="../../../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a> <span class="fn">(<a href="../../../.././Init/Control/StateRef.html#StateRefT'">StateRefT'</a> <a href="../../../.././Init/System/IO.html#IO.RealWorld">IO.RealWorld</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State">Lean.Meta.Grind.State</a> <a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GrindM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mapGrindM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L154-L155">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mapGrindM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mapGrindM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> → <a href="../../../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>} → <span class="fn"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">α</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mapGrindM">Lean.Meta.Grind.mapGrindM</a> <span class="fn">f</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Control/Basic.html#controlAt">controlAt</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a>
    <span class="fn">fun (<span class="fn">runInBase</span> : <span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a>} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a> <span class="fn">(<a href="../../../.././Init/Control/Basic.html#MonadControlT.stM">stM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a> <span class="fn">m</span> <span class="fn">β</span>)</span></span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">runInBase</span> <span class="fn">x</span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mapGrindM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.withoutReportingMVarIssues"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L157-L162">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withoutReportingMVarIssues"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withoutReportingMVarIssues</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> → <a href="../../../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></div></div><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withoutReportingMVarIssues">withoutReportingMVarIssues</a> x</code> executes <code>x</code> without reporting metavariables found during internalization.
See comment at <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.reportMVarIssue">Grind.Context.reportMVarIssue</a></code> for additional details.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.withoutReportingMVarIssues" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L164-L166">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Grind/Tactics.html#Lean.Grind.Config">Grind.Config</a></span></div></div><p>Returns the user-defined configuration options</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.config">config</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getTrueExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L168-L170">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getTrueExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Prelude.html#True">True</a></code> constant.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State.trueExpr">trueExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getTrueExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getFalseExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L172-L174">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getFalseExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Prelude.html#False">False</a></code> constant.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State.falseExpr">falseExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getFalseExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getBoolTrueExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L176-L178">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getBoolTrueExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolTrueExpr">Lean.Meta.Grind.getBoolTrueExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State.btrueExpr">btrueExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getBoolTrueExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getBoolFalseExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L180-L182">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getBoolFalseExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolFalseExpr">Lean.Meta.Grind.getBoolFalseExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State.bfalseExpr">bfalseExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getBoolFalseExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getNatZeroExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L184-L186">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getNatZeroExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getNatZeroExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code>0 : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></code> numeral.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getNatZeroExpr">Lean.Meta.Grind.getNatZeroExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State.natZExpr">natZExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getNatZeroExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.cheapCasesOnly"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L188-L189">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.cheapCasesOnly"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">cheapCasesOnly</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.cheapCasesOnly">Lean.Meta.Grind.cheapCasesOnly</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.cheapCases">cheapCases</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.cheapCasesOnly" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.reportMVarInternalization"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L191-L192">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.reportMVarInternalization"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">reportMVarInternalization</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.reportMVarInternalization">Lean.Meta.Grind.reportMVarInternalization</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.reportMVarIssue">reportMVarIssue</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.reportMVarInternalization" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isMatchEqLikeDeclName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L194-L198">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isMatchEqLikeDeclName"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isMatchEqLikeDeclName</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">declName</span> : <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code>declName</code> is the name of a <code>match</code> equation or a <code>match</code> congruence equation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isMatchEqLikeDeclName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.saveEMatchTheorem"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L200-L209">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.saveEMatchTheorem"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveEMatchTheorem</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">thm</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem">EMatchTheorem</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.saveEMatchTheorem" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.saveCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L211-L222">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.saveCases"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveCases</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">declName</span> : <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eager</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.saveCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getMethodsRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L224-L225">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMethodsRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.MethodsRef">Lean.Meta.Grind.MethodsRef✝</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethodsRef">Lean.Meta.Grind.getMethodsRef</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#MonadReader.read">read</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getMethodsRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getMaxGeneration"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L227-L229">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMaxGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMaxGeneration</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div></div><p>Returns maximum term generation that is considered during ematching.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMaxGeneration">Lean.Meta.Grind.getMaxGeneration</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Init/Grind/Tactics.html#Lean.Grind.Config.gen">gen</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getMaxGeneration" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.abstractNestedProofs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L231-L235">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.abstractNestedProofs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">abstractNestedProofs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Abstracts nested proofs in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>. This is a preprocessing step performed before internalization.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.abstractNestedProofs">Lean.Meta.Grind.abstractNestedProofs</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<a href="../../../.././Lean/Meta/AbstractNestedProofs.html#Lean.Meta.abstractNestedProofs">Lean.Meta.abstractNestedProofs</a> <span class="fn">e</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.abstractNestedProofs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.shareCommon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L237-L245">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.shareCommon"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">shareCommon</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Applies hash-consing to <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>. Recall that all expressions in a <code>grind</code> goal have
been hash-consed. We perform this step before we internalize expressions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.shareCommon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isTrueExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L247-L249">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isTrueExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is the internalized <code><a href="../../../.././Init/Prelude.html#True">True</a></code> expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isTrueExpr">Lean.Meta.Grind.isTrueExpr</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn">e</span> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isTrueExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isFalseExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L251-L253">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isFalseExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is the internalized <code><a href="../../../.././Init/Prelude.html#False">False</a></code> expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isFalseExpr">Lean.Meta.Grind.isFalseExpr</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn">e</span> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isFalseExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkHCongrWithArity"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L255-L268">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkHCongrWithArity"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkHCongrWithArity</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">numArgs</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem">CongrTheorem</a></span></div></div><p>Creates a congruence theorem for a <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code>-applications with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.numArgs">numArgs</a></code> arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkHCongrWithArity" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.reportIssue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L270-L277">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.reportIssue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">reportIssue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">msg</span> : <a href="../../../.././Lean/Message.html#Lean.MessageData">MessageData</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.reportIssue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.doElemReportIssue!__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L285-L286">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.doElemReportIssue!__"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">doElemReportIssue!__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.doElemReportIssue!__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ENode"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L288-L351">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Stores information for a node in the egraph.
Each internalized expression <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has an <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></code> associated with it.</p><ul class="structure_fields" id="Lean.Meta.Grind.ENode.mk"><li id="Lean.Meta.Grind.ENode.self" class="structure_field"><div class="structure_field_info">self : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div><div class="structure_field_doc"><p>Node represented by this ENode.</p></div></li><li id="Lean.Meta.Grind.ENode.next" class="structure_field"><div class="structure_field_info">next : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div><div class="structure_field_doc"><p>Next element in the equivalence class.</p></div></li><li id="Lean.Meta.Grind.ENode.root" class="structure_field"><div class="structure_field_info">root : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div><div class="structure_field_doc"><p>Root (aka canonical representative) of the equivalence class</p></div></li><li id="Lean.Meta.Grind.ENode.congr" class="structure_field"><div class="structure_field_info">congr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Init/Prelude.html#congr">congr</a></code> is the term <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></code> is congruent to.
We say <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></code> is the congruence class root if <code>isSameExpr <a href="../../../.././Init/Prelude.html#congr">congr</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></code>.
This field is initialized to <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></code> even if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is not an application.</p></div></li><li id="Lean.Meta.Grind.ENode.target?" class="structure_field"><div class="structure_field_info">target? : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div><div class="structure_field_doc"><p>When <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> was added to this equivalence class because of an equality <code>h : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a> = target</code>,
then we store <code>target</code> here, and <code>h</code> at <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.proof?">proof?</a></code>.</p></div></li><li id="Lean.Meta.Grind.ENode.proof?" class="structure_field"><div class="structure_field_info">proof? : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li><li id="Lean.Meta.Grind.ENode.flipped" class="structure_field"><div class="structure_field_info">flipped : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Proof has been flipped.</p></div></li><li id="Lean.Meta.Grind.ENode.size" class="structure_field"><div class="structure_field_info">size : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Number of elements in the equivalence class, this field is meaningless if node is not the root.</p></div></li><li id="Lean.Meta.Grind.ENode.interpreted" class="structure_field"><div class="structure_field_info">interpreted : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.interpreted">interpreted</a> := true</code> if node should be viewed as an abstract value.</p></div></li><li id="Lean.Meta.Grind.ENode.ctor" class="structure_field"><div class="structure_field_info">ctor : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.ctor">ctor</a> := true</code> if the head symbol is a constructor application.</p></div></li><li id="Lean.Meta.Grind.ENode.hasLambdas" class="structure_field"><div class="structure_field_info">hasLambdas : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.hasLambdas">hasLambdas</a> := true</code> if the equivalence class contains lambda expressions.</p></div></li><li id="Lean.Meta.Grind.ENode.heqProofs" class="structure_field"><div class="structure_field_info">heqProofs : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.heqProofs">heqProofs</a> := true</code>, then some proofs in the equivalence class are based
on heterogeneous equality.</p></div></li><li id="Lean.Meta.Grind.ENode.idx" class="structure_field"><div class="structure_field_info">idx : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Unique index used for pretty printing and debugging purposes.</p></div></li><li id="Lean.Meta.Grind.ENode.generation" class="structure_field"><div class="structure_field_info">generation : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>The generation in which this enode was created.</p></div></li><li id="Lean.Meta.Grind.ENode.mt" class="structure_field"><div class="structure_field_info">mt : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Modification time</p></div></li><li id="Lean.Meta.Grind.ENode.offset?" class="structure_field"><div class="structure_field_info">offset? : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div><div class="structure_field_doc"><p>The <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.offset?">offset?</a></code> field is used to propagate equalities from the <code>grind</code> congruence closure module
to the offset constraints module. When <code>grind</code> merges two equivalence classes, and both have
an associated <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.offset?">offset?</a></code> set to <code>some <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>, the equality is propagated. This field is
assigned during the internalization of offset terms.</p></div></li><li id="Lean.Meta.Grind.ENode.cutsat?" class="structure_field"><div class="structure_field_info">cutsat? : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div><div class="structure_field_doc"><p>The <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.cutsat?">cutsat?</a></code> field is used to propagate equalities from the <code>grind</code> congruence closure module
to the cutsat module. Its implementation is similar to the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.offset?">offset?</a></code> field.</p></div></li><li id="Lean.Meta.Grind.ENode.ring?" class="structure_field"><div class="structure_field_info">ring? : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div><div class="structure_field_doc"><p>The <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.ring?">ring?</a></code> field is used to propagate equalities from the <code>grind</code> congruence closure module
to the comm ring module. Its implementation is similar to the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.offset?">offset?</a></code> field.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.ENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedENode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L351-L351">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedENode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instReprENode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L351-L351">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprENode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/Repr.html#Repr">Repr</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprENode">Lean.Meta.Grind.instReprENode</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Repr.html#Repr.mk">{</a> <span class="fn">reprPrec</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.reprENode._@.Lean.Meta.Tactic.Grind.Types._hyg.2894">Lean.Meta.Grind.reprENode✝</a> <a href="../../../.././Init/Data/Repr.html#Repr.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ENode.isRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L353-L354">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span>.<span class="name">isRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isRoot">isRoot</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></span> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ENode.isRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ENode.isCongrRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L356-L357">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span>.<span class="name">isCongrRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isCongrRoot">isCongrRoot</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></span> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.congr">congr</a></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ENode.isCongrRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.NewFact"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L359-L362">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">NewFact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>New equalities and facts to be processed.</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.NewFact.eq">eq<span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">isHEq</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact">NewFact</a></li><li class="constructor" id="Lean.Meta.Grind.NewFact.fact">fact<span class="decl_args">
<span class="fn">(<span class="fn">prop </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact">NewFact</a></li></ul><details id="instances-for-list-Lean.Meta.Grind.NewFact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ENodeMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L364-L364">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENodeMap</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">Lean.Meta.Grind.ENodeMap</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">Lean.PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.ENodeKey">Lean.Meta.Grind.ENodeKey</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">Lean.Meta.Grind.ENode</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ENodeMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.CongrKey"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L366-L371">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrKey</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">enodes</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Key for the congruence table.
We need access to the <code>enodes</code> to be able to retrieve the equivalence class roots.</p><ul class="structure_fields" id="Lean.Meta.Grind.CongrKey.mk"><li id="Lean.Meta.Grind.CongrKey.e" class="structure_field"><div class="structure_field_info">e : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.CongrKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashableCongrKey"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L439-L440">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCongrKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">enodeMap</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">CongrKey</a> <span class="fn">enodeMap</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCongrKey">Lean.Meta.Grind.instHashableCongrKey</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#Hashable.mk">{</a> <span class="fn">hash</span> := <span class="fn">fun (<span class="fn">k</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">Lean.Meta.Grind.CongrKey</a> <span class="fn">enodeMap</span></span>) =&gt; <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.congrHash">Lean.Meta.Grind.congrHash✝</a> <span class="fn">enodeMap</span> <span class="fn"><span class="fn">k</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></span></span></span> <a href="../../../.././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqCongrKey"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L442-L443">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCongrKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">enodeMap</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">CongrKey</a> <span class="fn">enodeMap</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCongrKey">Lean.Meta.Grind.instBEqCongrKey</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <span class="fn">fun (<span class="fn">k1</span> <span class="fn">k2</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">Lean.Meta.Grind.CongrKey</a> <span class="fn">enodeMap</span></span>) =&gt; <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.isCongruent">Lean.Meta.Grind.isCongruent✝</a> <span class="fn">enodeMap</span> <span class="fn"><span class="fn">k1</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></span> <span class="fn"><span class="fn">k2</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></span></span></span> <a href="../../../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.CongrTable"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L445-L445">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTable"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrTable</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">enodeMap</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTable">Lean.Meta.Grind.CongrTable</a> <span class="fn">enodeMap</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">Lean.PHashSet</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">Lean.Meta.Grind.CongrKey</a> <span class="fn">enodeMap</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.CongrTable" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ParentSet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L448-L448">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentSet</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">Lean.Meta.Grind.ParentSet</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet">Std.TreeSet</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../../../.././Lean/Expr.html#Lean.Expr.quickComp">Lean.Expr.quickComp</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ParentSet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ParentMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L449-L449">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentMap</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentMap">Lean.Meta.Grind.ParentMap</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">Lean.PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.ENodeKey">Lean.Meta.Grind.ENodeKey</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">Lean.Meta.Grind.ParentSet</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ParentMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.PreInstance"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L451-L460">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PreInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>The E-matching module instantiates theorems using the <code>EMatchTheorem <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> and a (partial) assignment.
We want to avoid instantiating the same theorem with the same assignment more than once.
Therefore, we store the (pre-)instance information in set.
Recall that the proofs of activated theorems have been hash-consed.
The assignment contains internalized expressions, which have also been hash-consed.</p><ul class="structure_fields" id="Lean.Meta.Grind.PreInstance.mk"><li id="Lean.Meta.Grind.PreInstance.proof" class="structure_field"><div class="structure_field_info">proof : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.PreInstance.assignment" class="structure_field"><div class="structure_field_info">assignment : <span class="fn"><a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.PreInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashablePreInstance"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L462-L467">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashablePreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashablePreInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance">PreInstance</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqPreInstance"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L469-L475">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqPreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqPreInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance">PreInstance</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.PreInstanceSet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L477-L477">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstanceSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PreInstanceSet</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstanceSet">Lean.Meta.Grind.PreInstanceSet</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">Lean.PHashSet</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance">Lean.Meta.Grind.PreInstance</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.PreInstanceSet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.NewRawFact"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L479-L484">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">NewRawFact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>New raw fact to be preprocessed, and then asserted.</p><ul class="structure_fields" id="Lean.Meta.Grind.NewRawFact.mk"><li id="Lean.Meta.Grind.NewRawFact.proof" class="structure_field"><div class="structure_field_info">proof : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.NewRawFact.prop" class="structure_field"><div class="structure_field_info">prop : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.NewRawFact.generation" class="structure_field"><div class="structure_field_info">generation : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.NewRawFact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedNewRawFact"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L484-L484">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedNewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedNewRawFact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact">NewRawFact</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedNewRawFact">Lean.Meta.Grind.instInhabitedNewRawFact</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact.mk">{</a> <span class="fn">proof</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">prop</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">generation</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact.mk">}</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Canon.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L486-L491">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Canonicalizer state. See <code>Canon.lean</code> for additional details.</p><ul class="structure_fields" id="Lean.Meta.Grind.Canon.State.mk"><li id="Lean.Meta.Grind.Canon.State.argMap" class="structure_field"><div class="structure_field_info">argMap : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> (<a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a>) <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> (<a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>))</span></span></div></li><li id="Lean.Meta.Grind.Canon.State.canon" class="structure_field"><div class="structure_field_info">canon : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li><li id="Lean.Meta.Grind.Canon.State.proofCanon" class="structure_field"><div class="structure_field_info">proofCanon : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Canon.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Canon.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L491-L491">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.instInhabitedState">Lean.Meta.Grind.Canon.instInhabitedState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State.mk">{</a> <span class="fn">argMap</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">canon</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">proofCanon</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State.mk">}</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.CaseTrace"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L493-L498">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CaseTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Trace information for a case split.</p><ul class="structure_fields" id="Lean.Meta.Grind.CaseTrace.mk"><li id="Lean.Meta.Grind.CaseTrace.expr" class="structure_field"><div class="structure_field_info">expr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.CaseTrace.i" class="structure_field"><div class="structure_field_info">i : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.CaseTrace.num" class="structure_field"><div class="structure_field_info">num : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.CaseTrace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedCaseTrace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L498-L498">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCaseTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCaseTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace">CaseTrace</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCaseTrace">Lean.Meta.Grind.instInhabitedCaseTrace</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace.mk">{</a> <span class="fn">expr</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">i</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">num</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace.mk">}</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.EMatch.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L500-L523">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>E-matching related fields for the <code>grind</code> goal.</p><ul class="structure_fields" id="Lean.Meta.Grind.EMatch.State.mk"><li id="Lean.Meta.Grind.EMatch.State.thmMap" class="structure_field"><div class="structure_field_info">thmMap : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems">EMatchTheorems</a></div><div class="structure_field_doc"><p>Inactive global theorems. As we internalize terms, we activate theorems as we find their symbols.
Local theorem provided by users are added directly into <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State.newThms">newThms</a></code>.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.gmt" class="structure_field"><div class="structure_field_info">gmt : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Goal modification time.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.thms" class="structure_field"><div class="structure_field_info">thms : <span class="fn"><a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem">EMatchTheorem</a></span></div><div class="structure_field_doc"><p>Active theorems that we have performed ematching at least once.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.newThms" class="structure_field"><div class="structure_field_info">newThms : <span class="fn"><a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem">EMatchTheorem</a></span></div><div class="structure_field_doc"><p>Active theorems that we have not performed any round of ematching yet.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.numInstances" class="structure_field"><div class="structure_field_info">numInstances : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Number of theorem instances generated so far</p></div></li><li id="Lean.Meta.Grind.EMatch.State.num" class="structure_field"><div class="structure_field_info">num : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Number of E-matching rounds performed in this goal since the last case-split.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.preInstances" class="structure_field"><div class="structure_field_info">preInstances : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstanceSet">PreInstanceSet</a></div><div class="structure_field_doc"><p>(pre-)instances found so far. It includes instances that failed to be instantiated.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.nextThmIdx" class="structure_field"><div class="structure_field_info">nextThmIdx : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Next local E-match theorem idx.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.matchEqNames" class="structure_field"><div class="structure_field_info">matchEqNames : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a></span></div><div class="structure_field_doc"><p><code>match</code> auxiliary functions whose equations have already been created and activated.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.EMatch.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.EMatch.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L523-L523">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L525-L539">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Case-split information.</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.SplitInfo.default">default<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a><div class="inductive_ctor_doc"><p>Term <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> may be an inductive predicate, <code>match</code>-expression, <code>if</code>-expression, implication, etc.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitInfo.imp">imp<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">e</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.isForall">isForall</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a><div class="inductive_ctor_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is an implication and we want to split on its antecedent.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitInfo.arg">arg<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eq</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a><div class="inductive_ctor_doc"><p>Given applications <code>a</code> and <code>b</code>, case-split on whether the corresponding
<code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace.i">i</a></code>-th arguments are equal or not. The split is only performed if all other
arguments are already known to be equal or are also tagged as split candidates.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.SplitInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashableSplitInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L539-L539">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableSplitInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableSplitInfo">Lean.Meta.Grind.instHashableSplitInfo</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Hashable.mk">{</a> <span class="fn">hash</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.hashSplitInfo._@.Lean.Meta.Tactic.Grind.Types._hyg.5365">Lean.Meta.Grind.hashSplitInfo✝</a> <a href="../../../.././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSplitInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L539-L539">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitInfo">Lean.Meta.Grind.instInhabitedSplitInfo</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo.beq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L541-L545">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">beq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e₁</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">beq</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e₂</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">e₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">e₂</span>)</li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e₁</span> <span class="fn">h</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">beq</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e₂</span> <span class="fn">h_1</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">e₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">e₂</span>)</li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a₁</span> <span class="fn">b₁</span> <span class="fn">i₁</span> <span class="fn">eq₁</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">beq</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a₂</span> <span class="fn">b₂</span> <span class="fn">i₂</span> <span class="fn">eq₂</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   (<span class="fn">a₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a₂</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">b₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b₂</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">i₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">i₂</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">eq₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">eq₂</span>)</li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝¹</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">beq</a></span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitInfo.beq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqSplitInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L547-L548">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqSplitInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqSplitInfo">Lean.Meta.Grind.instBEqSplitInfo</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">Lean.Meta.Grind.SplitInfo.beq</a> <a href="../../../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo.getExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L550-L553">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.getExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">getExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">a</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.getExpr">getExpr</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">a</span> <span class="fn">a_1</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.getExpr">getExpr</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">a</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.forallDomain">forallDomain</a></span> <span class="fn">a_1</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a</span> <span class="fn">a_1</span> <span class="fn">a_2</span> <span class="fn">a_3</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.getExpr">getExpr</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a_3</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitInfo.getExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo.lt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L555-L561">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">lt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e₁</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e₂</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e₁</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.lt">lt</a></span> <span class="fn">e₂</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e₁</span> <span class="fn">h</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e₂</span> <span class="fn">h_1</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e₁</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.lt">lt</a></span> <span class="fn">e₂</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">i</span> <span class="fn">e₁</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a_1</span> <span class="fn">b_1</span> <span class="fn">i_1</span> <span class="fn">e₂</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e₁</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.lt">lt</a></span> <span class="fn">e₂</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e</span> <span class="fn">h</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝¹</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitInfo.lt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitArg"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L563-L567">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitArg"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Argument <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">arg</a> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitArg.type">type</a></code> of an application <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitArg.app">app</a></code> in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></code>.</p><ul class="structure_fields" id="Lean.Meta.Grind.SplitArg.mk"><li id="Lean.Meta.Grind.SplitArg.arg" class="structure_field"><div class="structure_field_info">arg : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.SplitArg.type" class="structure_field"><div class="structure_field_info">type : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.SplitArg.app" class="structure_field"><div class="structure_field_info">app : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.SplitArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Split.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L569-L604">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Case splitting related fields for the <code>grind</code> goal.</p><ul class="structure_fields" id="Lean.Meta.Grind.Split.State.mk"><li id="Lean.Meta.Grind.Split.State.num" class="structure_field"><div class="structure_field_info">num : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Number of splits performed to get to this goal.</p></div></li><li id="Lean.Meta.Grind.Split.State.casesTypes" class="structure_field"><div class="structure_field_info">casesTypes : <a href="../../../.././Lean/Meta/Tactic/Grind/Cases.html#Lean.Meta.Grind.CasesTypes">CasesTypes</a></div><div class="structure_field_doc"><p>Inductive datatypes marked for case-splitting</p></div></li><li id="Lean.Meta.Grind.Split.State.candidates" class="structure_field"><div class="structure_field_info">candidates : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div><div class="structure_field_doc"><p>Case-split candidates.</p></div></li><li id="Lean.Meta.Grind.Split.State.added" class="structure_field"><div class="structure_field_info">added : <span class="fn"><a href="../../../.././Std/Data/HashSet/Basic.html#Std.HashSet">Std.HashSet</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div><div class="structure_field_doc"><p>Case-splits that have been inserted at <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.candidates">candidates</a></code> at some point.</p></div></li><li id="Lean.Meta.Grind.Split.State.resolved" class="structure_field"><div class="structure_field_info">resolved : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.ENodeKey">ENodeKey</a></span></div><div class="structure_field_doc"><p>Case-splits that have already been performed, or that do not have to be performed anymore.</p></div></li><li id="Lean.Meta.Grind.Split.State.trace" class="structure_field"><div class="structure_field_info">trace : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace">CaseTrace</a></span></div><div class="structure_field_doc"><p>Sequence of cases steps that generated this goal. We only use this information for diagnostics.
Remark: <code>casesTrace.length ≥ numSplits</code> because we don't increase the counter for <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace.cases">cases</a></code>
applications that generated only 1 subgoal.</p></div></li><li id="Lean.Meta.Grind.Split.State.lookaheads" class="structure_field"><div class="structure_field_info">lookaheads : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div><div class="structure_field_doc"><p>Lookahead &quot;case-splits&quot;.</p></div></li><li id="Lean.Meta.Grind.Split.State.argPosMap" class="structure_field"><div class="structure_field_info">argPosMap : <span class="fn"><a href="../../../.././Std/Data/HashMap/Basic.html#Std.HashMap">Std.HashMap</a> (<a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>) <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span></div><div class="structure_field_doc"><p>A mapping <code>(a, b) ↦ is</code> s.t. for each <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">SplitInfo.arg</a> a b <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace.i">i</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact.eq">eq</a></code>
in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.candidates">candidates</a></code> or <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.lookaheads">lookaheads</a></code> we have <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace.i">i</a> ∈ is</code>.
We use this information to decide whether the split/lookahead is &quot;ready&quot;
to be tried or not.</p></div></li><li id="Lean.Meta.Grind.Split.State.argsAt" class="structure_field"><div class="structure_field_info">argsAt : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> (<a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a>) <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitArg">SplitArg</a>)</span></span></div><div class="structure_field_doc"><p>Mapping from pairs <code>(f, i)</code> to a list of arguments.
Each argument occurs as the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace.i">i</a></code>-th of an <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code>-application.
We use this information to add splits/lookaheads for
triggering extensionality theorems and model-based theory combination.
See <code>addSplitCandidatesForExt</code>.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Split.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Split.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L604-L604">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Clean.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L606-L610">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Clean name generator.</p><ul class="structure_fields" id="Lean.Meta.Grind.Clean.State.mk"><li id="Lean.Meta.Grind.Clean.State.used" class="structure_field"><div class="structure_field_info">used : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a></span></div></li><li id="Lean.Meta.Grind.Clean.State.next" class="structure_field"><div class="structure_field_info">next : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Clean.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Clean.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L610-L610">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.instInhabitedState">Lean.Meta.Grind.Clean.instInhabitedState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State.mk">{</a> <span class="fn">used</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">next</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State.mk">}</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L612-L646">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>The <code>grind</code> goal.</p><ul class="structure_fields" id="Lean.Meta.Grind.Goal.mk"><li id="Lean.Meta.Grind.Goal.mvarId" class="structure_field"><div class="structure_field_info">mvarId : <a href="../../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></div></li><li id="Lean.Meta.Grind.Goal.canon" class="structure_field"><div class="structure_field_info">canon : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State">Canon.State</a></div></li><li id="_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.Goal.enodeMap" class="structure_field"><div class="structure_field_info">enodeMap : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">Lean.Meta.Grind.ENodeMap</a></div></li><li id="Lean.Meta.Grind.Goal.exprs" class="structure_field"><div class="structure_field_info">exprs : <span class="fn"><a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li><li id="Lean.Meta.Grind.Goal.parents" class="structure_field"><div class="structure_field_info">parents : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentMap">ParentMap</a></div></li><li id="Lean.Meta.Grind.Goal.congrTable" class="structure_field"><div class="structure_field_info">congrTable : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTable">CongrTable</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.Goal.enodeMap">Lean.Meta.Grind.Goal.enodeMap✝</a> <span class="fn">self</span>)</span></span></div></li><li id="Lean.Meta.Grind.Goal.appMap" class="structure_field"><div class="structure_field_info">appMap : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/HeadIndex.html#Lean.HeadIndex">HeadIndex</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div><div class="structure_field_doc"><p>A mapping from each function application index (<code>HeadIndex</code>) to a list of applications with that index.
Recall that the <code>HeadIndex</code> for a constant is its constant name, and for a free variable,
it is its unique id.</p></div></li><li id="Lean.Meta.Grind.Goal.newFacts" class="structure_field"><div class="structure_field_info">newFacts : <span class="fn"><a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact">NewFact</a></span></div><div class="structure_field_doc"><p>Equations and propositions to be processed.</p></div></li><li id="Lean.Meta.Grind.Goal.inconsistent" class="structure_field"><div class="structure_field_info">inconsistent : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.inconsistent">inconsistent</a> := true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></code>s for <code><a href="../../../.././Init/Prelude.html#True">True</a></code> and <code><a href="../../../.././Init/Prelude.html#False">False</a></code> are in the same equivalence class.</p></div></li><li id="Lean.Meta.Grind.Goal.nextIdx" class="structure_field"><div class="structure_field_info">nextIdx : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Next unique index for creating ENodes</p></div></li><li id="Lean.Meta.Grind.Goal.newRawFacts" class="structure_field"><div class="structure_field_info">newRawFacts : <span class="fn"><a href="../../../.././Init/Data/Queue.html#Std.Queue">Std.Queue</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact">NewRawFact</a></span></div><div class="structure_field_doc"><p>new facts to be preprocessed and then asserted.</p></div></li><li id="Lean.Meta.Grind.Goal.facts" class="structure_field"><div class="structure_field_info">facts : <span class="fn"><a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div><div class="structure_field_doc"><p>Asserted facts</p></div></li><li id="Lean.Meta.Grind.Goal.extThms" class="structure_field"><div class="structure_field_info">extThms : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.ENodeKey">ENodeKey</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Ext.html#Lean.Meta.Ext.ExtTheorem">Ext.ExtTheorem</a>)</span></span></div><div class="structure_field_doc"><p>Cached extensionality theorems for types.</p></div></li><li id="Lean.Meta.Grind.Goal.ematch" class="structure_field"><div class="structure_field_info">ematch : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State">EMatch.State</a></div><div class="structure_field_doc"><p>State of the E-matching module.</p></div></li><li id="Lean.Meta.Grind.Goal.split" class="structure_field"><div class="structure_field_info">split : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State">Split.State</a></div><div class="structure_field_doc"><p>State of the case-splitting module.</p></div></li><li id="Lean.Meta.Grind.Goal.arith" class="structure_field"><div class="structure_field_info">arith : <a href="../../../.././Lean/Meta/Tactic/Grind/Arith/Types.html#Lean.Meta.Grind.Arith.State">Arith.State</a></div><div class="structure_field_doc"><p>State of arithmetic procedures.</p></div></li><li id="Lean.Meta.Grind.Goal.clean" class="structure_field"><div class="structure_field_info">clean : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State">Clean.State</a></div><div class="structure_field_doc"><p>State of the clean name generator.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Goal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedGoal"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L646-L646">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedGoal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedGoal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.hasSameRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L648-L649">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.hasSameRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">hasSameRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.hasSameRoot">hasSameRoot</a></span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.hasSameRoot">Lean.Meta.Grind.hasSameRoot✝</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.Goal.enodeMap">Lean.Meta.Grind.Goal.enodeMap✝</a> <span class="fn">g</span>)</span> <span class="fn">a</span> <span class="fn">b</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.hasSameRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.isCongruent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L651-L652">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.isCongruent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">isCongruent</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.isCongruent">isCongruent</a></span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.isCongruent">Lean.Meta.Grind.isCongruent✝</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.Goal.enodeMap">Lean.Meta.Grind.Goal.enodeMap✝</a> <span class="fn">g</span>)</span> <span class="fn">a</span> <span class="fn">b</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.isCongruent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.admit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L654-L655">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.admit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">admit</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.admit">admit</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></span>.<a href="../../../.././Lean/Meta/Tactic/Util.html#Lean.MVarId.admit">admit</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.admit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.GoalM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L657-L657">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">Lean.Meta.Grind.GoalM</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Control/StateRef.html#StateRefT'">StateRefT'</a> <a href="../../../.././Init/System/IO.html#IO.RealWorld">IO.RealWorld</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Lean.Meta.Grind.Goal</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GoalM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.GoalM.runCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L659-L660">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.runCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">runCore</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.runCore">Lean.Meta.Grind.GoalM.runCore</a> <span class="fn">goal</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Control/StateRef.html#StateRefT'.run">StateRefT'.run</a> <span class="fn">x</span> <span class="fn">goal</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GoalM.runCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.GoalM.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L662-L663">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.run"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">run</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.run">Lean.Meta.Grind.GoalM.run</a> <span class="fn">goal</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></span>.<a href="../../../.././Lean/Meta/Basic.html#Lean.MVarId.withContext">withContext</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.runCore">Lean.Meta.Grind.GoalM.runCore</a> <span class="fn">goal</span> <span class="fn">x</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GoalM.run" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.GoalM.run'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L665-L666">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.run'"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">run'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.run'">Lean.Meta.Grind.GoalM.run'</a> <span class="fn">goal</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></span>.<a href="../../../.././Lean/Meta/Basic.html#Lean.MVarId.withContext">withContext</a></span> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn">x</span> *&gt; <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>)</span>.<a href="../../../.././Init/Control/StateRef.html#StateRefT'.run'">run'</a></span> <span class="fn">goal</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GoalM.run'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.updateLastTag"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L668-L673">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.updateLastTag"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">updateLastTag</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.updateLastTag" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.«doElemTrace_goal[_]__»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L679-L685">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.«doElemTrace_goal[_]__»"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">«doElemTrace_goal[_]__»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Macro similar to <code>trace[...]</code>, but it includes the trace message <code>trace[grind] &quot;working on &lt;current goal&gt;&quot;</code>
if the tag has changed since the last trace message.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.«doElemTrace_goal[_]__»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.markTheoremInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L687-L696">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.markTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markTheoremInstance</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">assignment</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>A helper function used to mark a theorem instance found by the E-matching module.
It returns <code>true</code> if it is a new instance and <code>false</code> otherwise.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.markTheoremInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.addNewRawFact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L698-L705">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.addNewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addNewRawFact</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">proof </span><span class="fn">prop</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Adds a new fact <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact.prop">prop</a></code> with proof <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to the queue for preprocessing and the assertion.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.addNewRawFact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.addTheoremInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L707-L711">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.addTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addTheoremInstance</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">thm</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem">EMatchTheorem</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">proof </span><span class="fn">prop</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Adds a new theorem instance produced using E-matching.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.addTheoremInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.checkMaxInstancesExceeded"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L713-L715">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxInstancesExceeded"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxInstancesExceeded</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the maximum number of instances has been reached.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxInstancesExceeded">Lean.Meta.Grind.checkMaxInstancesExceeded</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.ematch">ematch</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State.numInstances">numInstances</a></span> <a href="../../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn"><span class="fn">__do_lift_1</span>.<a href="../../../.././Init/Grind/Tactics.html#Lean.Grind.Config.instances">instances</a></span>))</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.checkMaxInstancesExceeded" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.checkMaxCaseSplit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L717-L719">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxCaseSplit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the maximum number of case-splits has been reached.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxCaseSplit">Lean.Meta.Grind.checkMaxCaseSplit</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.split">split</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.num">num</a></span> <a href="../../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn"><span class="fn">__do_lift_1</span>.<a href="../../../.././Init/Grind/Tactics.html#Lean.Grind.Config.splits">splits</a></span>))</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.checkMaxCaseSplit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.checkMaxEmatchExceeded"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L721-L723">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxEmatchExceeded"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxEmatchExceeded</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the maximum number of E-matching rounds has been reached.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxEmatchExceeded">Lean.Meta.Grind.checkMaxEmatchExceeded</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.ematch">ematch</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State.num">num</a></span> <a href="../../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn"><span class="fn">__do_lift_1</span>.<a href="../../../.././Init/Grind/Tactics.html#Lean.Grind.Config.ematch">ematch</a></span>))</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.checkMaxEmatchExceeded" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getENode?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L725-L730">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getENode?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><p>Returns <code>some n</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been &quot;internalized&quot; into the
Otherwise, returns <code>none</code>s.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PersistentHashMap.find?">Lean.PersistentHashMap.find?</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.Goal.enodeMap">Lean.Meta.Grind.Goal.enodeMap✝</a> <span class="fn">goal</span>)</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.ENodeKey.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.ENodeKey.mk">}</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getENode?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getENode?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L732-L734">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getENode?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span></div></div><p>Returns <code>some n</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been &quot;internalized&quot; into the
Otherwise, returns <code>none</code>s.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?">Lean.Meta.Grind.getENode?</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getENode?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.throwNonInternalizedExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L736-L737">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.throwNonInternalizedExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">throwNonInternalizedExpr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.throwNonInternalizedExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L739-L743">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><p>Returns node associated with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>. It assumes <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode">getENode</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PersistentHashMap.find?">Lean.PersistentHashMap.find?</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.Goal.enodeMap">Lean.Meta.Grind.Goal.enodeMap✝</a> <span class="fn">goal</span>)</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.ENodeKey.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.ENodeKey.mk">}</a></span> with
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">n</span></span>
  | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.throwNonInternalizedExpr">Lean.Meta.Grind.throwNonInternalizedExpr</a> <span class="fn">e</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L745-L747">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><p>Returns node associated with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>. It assumes <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode">getENode</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getGeneration"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L749-L752">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getGeneration</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div></div><p>Returns the generation of the given term. Is assumes it has been internalized</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getGeneration">Lean.Meta.Grind.getGeneration</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__discr</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?">Lean.Meta.Grind.getENode?</a> <span class="fn">e</span></span>
  <span class="fn">match <span class="fn">__discr</span> with
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.generation">generation</a></span></span>
    | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">0</span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getGeneration" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqTrue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L754-L756">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqTrue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is in the equivalence class of <code><a href="../../../.././Init/Prelude.html#True">True</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqTrue">Lean.Meta.Grind.isEqTrue</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">e</span></span>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span> <span class="fn">__do_lift_1</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqTrue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqFalse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L758-L760">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqFalse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is in the equivalence class of <code><a href="../../../.././Init/Prelude.html#False">False</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqFalse">Lean.Meta.Grind.isEqFalse</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">e</span></span>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span> <span class="fn">__do_lift_1</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqFalse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqBoolTrue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L762-L764">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqBoolTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqBoolTrue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is in the equivalence class of <code><a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqBoolTrue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqBoolFalse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L766-L768">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqBoolFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqBoolFalse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is in the equivalence class of <code><a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqBoolFalse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L770-L777">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqv"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqv</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code>a</code> and <code>b</code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L779-L782">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the root of its equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isRoot">Lean.Meta.Grind.isRoot</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__discr</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?">Lean.Meta.Grind.getENode?</a> <span class="fn">e</span></span>
  <span class="fn">match <span class="fn">__discr</span> with
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span> <span class="fn">e</span>)</span></span>
    | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getRoot?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L784-L787">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getRoot?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> IF <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot?">getRoot?</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(do
      let <span class="fn">__discr</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span></span>
      <span class="fn">match <span class="fn">__discr</span> with
        | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span>)</span></span>
        | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></span>)</span>.<a href="../../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getRoot?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getRoot?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L789-L791">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRoot?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> IF <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot?">Lean.Meta.Grind.getRoot?</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot?">getRoot?</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getRoot?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L793-L795">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot">getRoot</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode">getENode</a></span> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L797-L799">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot">Lean.Meta.Grind.getRoot</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot">getRoot</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getRootENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L801-L803">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRootENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><p>Returns the root enode in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode">Lean.Meta.Grind.getRootENode</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot">Lean.Meta.Grind.getRoot</a> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getRootENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getRootENode?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L805-L808">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRootENode?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span></div></div><p>Returns the root enode in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> if it is in an equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode?">Lean.Meta.Grind.getRootENode?</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__discr</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?">Lean.Meta.Grind.getENode?</a> <span class="fn">e</span></span>
  <span class="fn">match <span class="fn">__discr</span> with
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?">Lean.Meta.Grind.getENode?</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span></span>
    | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getRootENode?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getNext?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L810-L816">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getNext?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the next element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>
if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has been internalized in the given goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext?">getNext?</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(do
      let <span class="fn">__discr</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span></span>
      <span class="fn">match <span class="fn">__discr</span> with
        | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.next">next</a></span>)</span></span>
        | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></span>)</span>.<a href="../../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getNext?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getNext"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L818-L820">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getNext</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the next element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext">getNext</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode">getENode</a></span> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.next">next</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getNext" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getNext"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L822-L824">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getNext"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getNext</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getNext">Lean.Meta.Grind.getNext</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext">getNext</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getNext" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.alreadyInternalized"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L826-L828">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.alreadyInternalized"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">alreadyInternalized</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.alreadyInternalized">Lean.Meta.Grind.alreadyInternalized</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PersistentHashMap.contains">Lean.PersistentHashMap.contains</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.Goal.enodeMap">Lean.Meta.Grind.Goal.enodeMap✝</a> <span class="fn">__do_lift</span>)</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.ENodeKey.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.ENodeKey.mk">}</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.alreadyInternalized" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getTarget?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L830-L832">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getTarget?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getTarget?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getTarget?">getTarget?</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(do
      let <span class="fn">__discr</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span></span>
      <span class="fn">match <span class="fn">__discr</span> with
        | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.target?">target?</a></span></span>
        | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></span>)</span>.<a href="../../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getTarget?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getTarget?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L834-L835">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTarget?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getTarget?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTarget?">Lean.Meta.Grind.getTarget?</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getTarget?">getTarget?</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getTarget?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L837-L850">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqCore</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">isHEq</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>If <code>isHEq</code> is <code>false</code>, it pushes <code>lhs = rhs</code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.
Otherwise, it pushes <code><a href="../../../.././Init/Prelude.html#HEq">HEq</a> lhs rhs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.hasSameType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L852-L854">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasSameType"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">hasSameType</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Return <code>true</code> if <code>a</code> and <code>b</code> have the same type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasSameType">Lean.Meta.Grind.hasSameType</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.withDefault">Lean.Meta.withDefault</a> <span class="fn">do
    let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.inferType">Lean.Meta.inferType</a> <span class="fn">a</span></span>
    let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.inferType">Lean.Meta.inferType</a> <span class="fn">b</span></span>
    <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.isDefEq">Lean.Meta.isDefEq</a> <span class="fn">__do_lift</span> <span class="fn">__do_lift_1</span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.hasSameType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqHEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L856-L860">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqHEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqHEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqHEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L862-L864">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>lhs = rhs</code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">lhs</span> <span class="fn">rhs</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqCore">Lean.Meta.Grind.pushEqCore</a> <span class="fn">lhs</span> <span class="fn">rhs</span> <span class="fn">proof</span> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushHEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L866-L868">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushHEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushHEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code><a href="../../../.././Init/Prelude.html#HEq">HEq</a> lhs rhs</code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushHEq">Lean.Meta.Grind.pushHEq</a> <span class="fn">lhs</span> <span class="fn">rhs</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqCore">Lean.Meta.Grind.pushEqCore</a> <span class="fn">lhs</span> <span class="fn">rhs</span> <span class="fn">proof</span> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushHEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqTrue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L870-L872">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqTrue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>a = <a href="../../../.././Init/Prelude.html#True">True</a></code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqTrue">Lean.Meta.Grind.pushEqTrue</a> <span class="fn">a</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">a</span> <span class="fn">__do_lift</span> <span class="fn">proof</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqTrue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqFalse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L874-L876">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqFalse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>a = <a href="../../../.././Init/Prelude.html#False">False</a></code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqFalse">Lean.Meta.Grind.pushEqFalse</a> <span class="fn">a</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">a</span> <span class="fn">__do_lift</span> <span class="fn">proof</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqFalse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqBoolTrue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L878-L880">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqBoolTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqBoolTrue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>a = <a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqBoolTrue">Lean.Meta.Grind.pushEqBoolTrue</a> <span class="fn">a</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolTrueExpr">Lean.Meta.Grind.getBoolTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">a</span> <span class="fn">__do_lift</span> <span class="fn">proof</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqBoolTrue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqBoolFalse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L882-L884">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqBoolFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqBoolFalse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>a = <a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqBoolFalse">Lean.Meta.Grind.pushEqBoolFalse</a> <span class="fn">a</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolFalseExpr">Lean.Meta.Grind.getBoolFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">a</span> <span class="fn">__do_lift</span> <span class="fn">proof</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqBoolFalse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.registerParent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L886-L893">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.registerParent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">registerParent</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">parent </span><span class="fn">child</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Records that <code>parent</code> is a parent of <code>child</code>. This function actually stores the
information in the root (aka canonical representative) of <code>child</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.registerParent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getParents"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L895-L902">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getParents"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getParents</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a></span></div></div><p>Returns the set of expressions <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is a child of, or an expression in
<code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>s equivalence class is a child of.
The information is only up to date if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is the root (aka canonical representative) of the equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getParents">Lean.Meta.Grind.getParents</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn">match <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PersistentHashMap.find?">Lean.PersistentHashMap.find?</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.parents">parents</a></span> <a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.ENodeKey.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.ENodeKey.mk">}</a></span> with
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">parents</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">parents</span></span>
    | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getParents" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.resetParentsOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L904-L908">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.resetParentsOf"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">resetParentsOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Removes the entry <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a> ↦ <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.parents">parents</a></code> from the parent map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.resetParentsOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.copyParentsTo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L910-L918">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.copyParentsTo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">copyParentsTo</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">parents</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">root</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Copy <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.parents">parents</a></code> to the parents of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></code>.
<code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></code> must be the root of its equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.copyParentsTo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkENodeCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L920-L935">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkENodeCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkENodeCore</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">interpreted </span><span class="fn">ctor</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkENodeCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L937-L945">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Creates an <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></code> for <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> if one does not already exist.
This method assumes <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has been hashconsed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.setENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L947-L951">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.setENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">setENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.setENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Offset.processNewEq"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L953-L958">source</a></div><div class="attributes">@[extern  lean_process_new_offset_eq]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Arith.Offset.processNewEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Offset</span>.<span class="name">processNewEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Notifies the offset constraint module that <code>a = b</code> where
<code>a</code> and <code>b</code> are terms that have been internalized by this module.</p></div></div><div class="decl" id="Lean.Meta.Grind.isNatNum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L960-L964">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isNatNum"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isNatNum</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is a numeral and has type <code><a href="../../../.././Init/Prelude.html#Nat">Nat</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isNatNum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.markAsOffsetTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L966-L976">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.markAsOffsetTerm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markAsOffsetTerm</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Marks <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> as a term of interest to the offset constraint module.
If the root of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>s equivalence class has already a term of interest,
a new equality is propagated to the offset module.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.markAsOffsetTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.processNewEq"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L978-L983">source</a></div><div class="attributes">@[extern  lean_process_cutsat_eq]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Arith.Cutsat.processNewEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">processNewEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Notifies the cutsat module that <code>a = b</code> where
<code>a</code> and <code>b</code> are terms that have been internalized by this module.</p></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.processNewDiseq"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L985-L990">source</a></div><div class="attributes">@[extern  lean_process_cutsat_diseq]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Arith.Cutsat.processNewDiseq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">processNewDiseq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Notifies the cutsat module that <code>a ≠ b</code> where
<code>a</code> and <code>b</code> are terms that have been internalized by this module.</p></div></div><div class="decl" id="Lean.Meta.Grind.isNonnegIntNum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L992-L996">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isNonnegIntNum"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isNonnegIntNum</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is a nonegative numeral and has type <code><a href="../../../.././Init/Data/Int/Basic.html#Int">Int</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isNonnegIntNum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isIntNum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L998-L1004">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isIntNum"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isIntNum</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is a numeral and has type <code><a href="../../../.././Init/Data/Int/Basic.html#Int">Int</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isIntNum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isNum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1006-L1008">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isNum"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isNum</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is a numeral supported by cutsat.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isNum">Lean.Meta.Grind.isNum</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isNatNum">Lean.Meta.Grind.isNatNum</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isIntNum">Lean.Meta.Grind.isIntNum</a> <span class="fn">e</span></span>)</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isNum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.hasType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1010-L1014">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasType"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">hasType</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">t </span><span class="fn">α</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if type of <code>t</code> is definitionally equal to <code>α</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasType">Lean.Meta.Grind.hasType</a> <span class="fn">t</span> <span class="fn">α</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.withDefault">Lean.Meta.withDefault</a> <span class="fn">do
    let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.inferType">Lean.Meta.inferType</a> <span class="fn">t</span></span>
    <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.isDefEq">Lean.Meta.isDefEq</a> <span class="fn">__do_lift</span> <span class="fn">α</span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.hasType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.forEachDiseq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1016-L1024">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.forEachDiseq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachDiseq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">parents</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>For each equality <code>b = c</code> in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.parents">parents</a></code>, executes <code>k b c</code> IF</p><ul>
<li><code>b = c</code> is equal to <code><a href="../../../.././Init/Prelude.html#False">False</a></code>, and</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.forEachDiseq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.propagateCutsatDiseq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1026-L1042">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateCutsatDiseq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateCutsatDiseq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Given <code>lhs</code> and <code>rhs</code> that are known to be disequal, checks whether
<code>lhs</code> and <code>rhs</code> have cutsat terms <code>e₁</code> and <code>e₂</code> attached to them,
and invokes process <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Arith.Cutsat.processNewDiseq">Arith.Cutsat.processNewDiseq</a> e₁ e₂</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.propagateCutsatDiseq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.propagateCutsatDiseq.get?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1038-L1042">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateCutsatDiseq.get?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateCutsatDiseq</span>.<span class="name">get?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.propagateCutsatDiseq.get?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.propagateCutsatDiseqs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1044-L1049">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateCutsatDiseqs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateCutsatDiseqs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">parents</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Traverses disequalities in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.parents">parents</a></code>, and propagate the ones relevant to the
cutsat module.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateCutsatDiseqs">Lean.Meta.Grind.propagateCutsatDiseqs</a> <span class="fn">parents</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.forEachDiseq">Lean.Meta.Grind.forEachDiseq</a> <span class="fn">parents</span> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateCutsatDiseq">Lean.Meta.Grind.propagateCutsatDiseq</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.propagateCutsatDiseqs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.markAsCutsatTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1051-L1062">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.markAsCutsatTerm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markAsCutsatTerm</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Marks <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> as a term of interest to the cutsat module.
If the root of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>s equivalence class has already a term of interest,
a new equality is propagated to the cutsat module.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.markAsCutsatTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.CommRing.processNewEq"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1064-L1069">source</a></div><div class="attributes">@[extern  lean_process_ring_eq]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Arith.CommRing.processNewEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">CommRing</span>.<span class="name">processNewEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Notifies the comm ring module that <code>a = b</code> where
<code>a</code> and <code>b</code> are terms that have been internalized by this module.</p></div></div><div class="decl" id="Lean.Meta.Grind.Arith.CommRing.processNewDiseq"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1071-L1076">source</a></div><div class="attributes">@[extern  lean_process_ring_diseq]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Arith.CommRing.processNewDiseq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">CommRing</span>.<span class="name">processNewDiseq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Notifies the comm ring module that <code>a ≠ b</code> where
<code>a</code> and <code>b</code> are terms that have been internalized by this module.</p></div></div><div class="decl" id="Lean.Meta.Grind.propagateCommRingDiseq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1078-L1089">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateCommRingDiseq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateCommRingDiseq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Given <code>lhs</code> and <code>rhs</code> that are known to be disequal, checks whether
<code>lhs</code> and <code>rhs</code> have ring terms <code>e₁</code> and <code>e₂</code> attached to them,
and invokes process <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Arith.CommRing.processNewDiseq">Arith.CommRing.processNewDiseq</a> e₁ e₂</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.propagateCommRingDiseq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.propagateCommRingDiseq.get?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1088-L1089">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateCommRingDiseq.get?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateCommRingDiseq</span>.<span class="name">get?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateCommRingDiseq.get?">Lean.Meta.Grind.propagateCommRingDiseq.get?</a> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode">Lean.Meta.Grind.getRootENode</a> <span class="fn">a</span></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.ring?">ring?</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.propagateCommRingDiseq.get?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.propagateCommRingDiseqs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1091-L1096">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateCommRingDiseqs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateCommRingDiseqs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">parents</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Traverses disequalities in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.parents">parents</a></code>, and propagate the ones relevant to the
comm ring module.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateCommRingDiseqs">Lean.Meta.Grind.propagateCommRingDiseqs</a> <span class="fn">parents</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.forEachDiseq">Lean.Meta.Grind.forEachDiseq</a> <span class="fn">parents</span> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateCommRingDiseq">Lean.Meta.Grind.propagateCommRingDiseq</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.propagateCommRingDiseqs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.markAsCommRingTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1098-L1109">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.markAsCommRingTerm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markAsCommRingTerm</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Marks <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> as a term of interest to the ring module.
If the root of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>s equivalence class has already a term of interest,
a new equality is propagated to the ring module.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.markAsCommRingTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isCongrRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1111-L1113">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isCongrRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> is <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is the root of its congruence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isCongrRoot">Lean.Meta.Grind.isCongrRoot</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isCongrRoot">isCongrRoot</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isCongrRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getCongrRoot"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1115-L1119">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getCongrRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root of the congruence class containing <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p></div></div><div class="decl" id="Lean.Meta.Grind.isInconsistent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1121-L1123">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isInconsistent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isInconsistent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Return <code>true</code> if the goal is inconsistent.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isInconsistent">Lean.Meta.Grind.isInconsistent</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.inconsistent">inconsistent</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isInconsistent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqProof"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1125-L1131">source</a></div><div class="attributes">@[extern  lean_grind_mk_eq_proof]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = b</code>.
It assumes <code>a</code> and <code>b</code> are in the same equivalence class, and have the same type.</p></div></div><div class="decl" id="Lean.Meta.Grind.mkHEqProof"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1133-L1139">source</a></div><div class="attributes">@[extern  lean_grind_mk_heq_proof]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkHEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkHEqProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code><a href="../../../.././Init/Prelude.html#HEq">HEq</a> a b</code>.
It assumes <code>a</code> and <code>b</code> are in the same equivalence class.</p></div></div><div class="decl" id="Lean.Meta.Grind.internalize"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1142-L1143">source</a></div><div class="attributes">@[extern  lean_grind_internalize]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.internalize"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">internalize</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">parent?</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span> := <a href="../../../.././Init/Prelude.html#Option.none">none</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.processNewFacts"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1146-L1147">source</a></div><div class="attributes">@[extern  lean_grind_process_new_facts]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.processNewFacts"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">processNewFacts</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.mkEqHEqProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1149-L1157">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqHEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqHEqProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = b</code> if they have the same type. Otherwise, returns a proof of <code><a href="../../../.././Init/Prelude.html#HEq">HEq</a> a b</code>.
It assumes <code>a</code> and <code>b</code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqHEqProof">Lean.Meta.Grind.mkEqHEqProof</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasSameType">Lean.Meta.Grind.hasSameType</a> <span class="fn">a</span> <span class="fn">b</span>)</span></span>
  <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn">__do_lift</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkHEqProof">Lean.Meta.Grind.mkHEqProof</a> <span class="fn">a</span> <span class="fn">b</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqHEqProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqTrueProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1159-L1164">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqTrueProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqTrueProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = <a href="../../../.././Init/Prelude.html#True">True</a></code>.
It assumes <code>a</code> and <code><a href="../../../.././Init/Prelude.html#True">True</a></code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqTrueProof">Lean.Meta.Grind.mkEqTrueProof</a> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqTrueProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqFalseProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1166-L1171">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqFalseProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqFalseProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = <a href="../../../.././Init/Prelude.html#False">False</a></code>.
It assumes <code>a</code> and <code><a href="../../../.././Init/Prelude.html#False">False</a></code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqFalseProof">Lean.Meta.Grind.mkEqFalseProof</a> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqFalseProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqBoolTrueProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1173-L1178">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqBoolTrueProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqBoolTrueProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = <a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code>.
It assumes <code>a</code> and <code><a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqBoolTrueProof">Lean.Meta.Grind.mkEqBoolTrueProof</a> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolTrueExpr">Lean.Meta.Grind.getBoolTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqBoolTrueProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqBoolFalseProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1180-L1185">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqBoolFalseProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqBoolFalseProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = <a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code>.
It assumes <code>a</code> and <code><a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqBoolFalseProof">Lean.Meta.Grind.mkEqBoolFalseProof</a> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolFalseExpr">Lean.Meta.Grind.getBoolFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqBoolFalseProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.markAsInconsistent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1187-L1191">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.markAsInconsistent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markAsInconsistent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Marks current goal as inconsistent without assigning <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.markAsInconsistent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.assignFalseProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1193-L1202">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.MVarId.assignFalseProof"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">assignFalseProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <a href="../../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">falseProof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Assign the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></code> using the given proof of <code><a href="../../../.././Init/Prelude.html#False">False</a></code>.
If type of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></code> is not <code><a href="../../../.././Init/Prelude.html#False">False</a></code>, then use <code><a href="../../../.././Init/Prelude.html#False.elim">False.elim</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.MVarId.assignFalseProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.closeGoal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1204-L1212">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.closeGoal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">closeGoal</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">falseProof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Closes the current goal using the given proof of <code><a href="../../../.././Init/Prelude.html#False">False</a></code> and
marks it as inconsistent if it is not already marked so.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.closeGoal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getExprs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1214-L1216">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getExprs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getExprs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Returns all enodes in the goal</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getExprs">Lean.Meta.Grind.getExprs</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.exprs">exprs</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getExprs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.traverseEqc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1218-L1225">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.traverseEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">traverseEqc</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Executes <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code> to each term in the equivalence class containing <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.traverseEqc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.foldEqc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1227-L1237">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.foldEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">foldEqc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">init</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span></div></div><p>Folds using <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code> and <code>init</code> over the equivalence class containing <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.foldEqc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.forEachENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1239-L1242">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.forEachENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.forEachENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.filterENodes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1244-L1249">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.filterENodes"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">filterENodes</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.filterENodes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.forEachEqcRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1251-L1255">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.forEachEqcRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachEqcRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.forEachEqcRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Propagator"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1257-L1257">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Propagator</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator">Lean.Meta.Grind.Propagator</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">Lean.Meta.Grind.GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span>)</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Propagator" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Fallback"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1258-L1258">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Fallback"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Fallback</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Fallback">Lean.Meta.Grind.Fallback</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">Lean.Meta.Grind.GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Fallback" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Methods"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1260-L1264">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Methods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.Grind.Methods.mk"><li id="Lean.Meta.Grind.Methods.propagateUp" class="structure_field"><div class="structure_field_info">propagateUp : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator">Propagator</a></div></li><li id="Lean.Meta.Grind.Methods.propagateDown" class="structure_field"><div class="structure_field_info">propagateDown : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator">Propagator</a></div></li><li id="Lean.Meta.Grind.Methods.fallback" class="structure_field"><div class="structure_field_info">fallback : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Fallback">Fallback</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Methods" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedMethods"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1264-L1264">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedMethods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods">Methods</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedMethods">Lean.Meta.Grind.instInhabitedMethods</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.mk">{</a> <span class="fn">propagateUp</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">propagateDown</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">fallback</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.mk">}</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Methods.toMethodsRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1266-L1267">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.toMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Methods</span>.<span class="name">toMethodsRef</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods">Methods</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.MethodsRef">Lean.Meta.Grind.MethodsRef✝</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">m</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.toMethodsRef">toMethodsRef</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.toMethodsRef.unsafe_impl_3">Lean.Meta.Grind.Methods.toMethodsRef.unsafe_impl_3</a> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Methods.toMethodsRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getMethods"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1272-L1273">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMethods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods">Methods</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods">Lean.Meta.Grind.getMethods</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethodsRef">Lean.Meta.Grind.getMethodsRef</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.MethodsRef.toMethods">toMethods</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getMethods" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.propagateUp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1275-L1276">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateUp"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateUp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateUp">Lean.Meta.Grind.propagateUp</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods">Lean.Meta.Grind.getMethods</a></span>
  <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.propagateUp">propagateUp</a></span> <span class="fn">e</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.propagateUp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.propagateDown"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1278-L1279">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateDown"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateDown</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateDown">Lean.Meta.Grind.propagateDown</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods">Lean.Meta.Grind.getMethods</a></span>
  <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.propagateDown">propagateDown</a></span> <span class="fn">e</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.propagateDown" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.applyFallback"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1281-L1283">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.applyFallback"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">applyFallback</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.applyFallback">Lean.Meta.Grind.applyFallback</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods">Lean.Meta.Grind.getMethods</a></span>
  let fallback : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">Lean.Meta.Grind.GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span> := <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.fallback">fallback</a></span>
  <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.applyFallback" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getEqc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1285-L1295">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getEqc</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns expressions in the given expression equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqc">getEqc</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqc.go">Lean.Meta.Grind.Goal.getEqc.go</a> <span class="fn">goal</span> <span class="fn">e</span> <span class="fn">e</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getEqc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getEqc.go"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1289-L1295">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqc.go"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getEqc</span>.<span class="name">go</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">first </span><span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">acc</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.getEqc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1297-L1299">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getEqc</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Returns expressions in the given expression equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getEqc">Lean.Meta.Grind.getEqc</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqc">getEqc</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getEqc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getEqcs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1301-L1308">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqcs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getEqcs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Returns all equivalence classes in the current goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getEqcs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getEqcs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1310-L1312">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getEqcs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getEqcs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span>)</span></span></div></div><p>Returns all equivalence classes in the current goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getEqcs">Lean.Meta.Grind.getEqcs</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqcs">getEqcs</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getEqcs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isKnownCaseSplit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1314-L1320">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isKnownCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isKnownCaseSplit</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code>s</code> has been already added to the case-split list at one point.
Remark: this function returns <code>true</code> even if the split has already been resolved
and is not in the list anymore.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isKnownCaseSplit">Lean.Meta.Grind.isKnownCaseSplit</a> <span class="fn">s</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.split">split</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.added">added</a></span>.<a href="../../../.././Std/Data/HashSet/Basic.html#Std.HashSet.contains">contains</a></span> <span class="fn">s</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isKnownCaseSplit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isResolvedCaseSplit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1322-L1324">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isResolvedCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isResolvedCaseSplit</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is a case-split that does not need to be performed anymore.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isResolvedCaseSplit">Lean.Meta.Grind.isResolvedCaseSplit</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PersistentHashSet.contains">Lean.PersistentHashSet.contains</a> <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.split">split</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.resolved">resolved</a></span> <a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.ENodeKey.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ENodeKey.html#Lean.Meta.Grind.ENodeKey.mk">}</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isResolvedCaseSplit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.markCaseSplitAsResolved"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1326-L1334">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.markCaseSplitAsResolved"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markCaseSplitAsResolved</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Marks <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> as a case-split that does not need to be performed anymore.
Remark: we currently use this feature to disable <code>match</code>-case-splits.
Remark: we also use this feature to record the case-splits that have already been performed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.markCaseSplitAsResolved" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.addSplitCandidate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1344-L1352">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.addSplitCandidate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addSplitCandidate</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">sinfo</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Inserts <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> into the list of case-split candidates if it was not inserted before.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.addSplitCandidate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getExtTheorems"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1354-L1369">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getExtTheorems"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getExtTheorems</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">type</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Ext.html#Lean.Meta.Ext.ExtTheorem">Ext.ExtTheorem</a>)</span></span></div></div><p>Returns extensionality theorems for the given type if available.
If <code>Config.ext</code> is <code>false</code>, the result is <code>#[]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getExtTheorems" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.synthesizeInstanceAndAssign"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1371-L1377">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.synthesizeInstanceAndAssign"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">synthesizeInstanceAndAssign</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">type</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Helper function for instantiating a type class <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitArg.type">type</a></code>, and
then using the result to perform <code>isDefEq x val</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.synthesizeInstanceAndAssign" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.addLookaheadCandidate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1379-L1383">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.addLookaheadCandidate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addLookaheadCandidate</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">sinfo</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Add a new lookahead candidate.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.addLookaheadCandidate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.withoutModifyingState"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Lean/Meta/Tactic/Grind/Types.lean#L1385-L1395">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withoutModifyingState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withoutModifyingState</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span></div></div><p>Helper function for executing <code>x</code> with a fresh <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.newFacts">newFacts</a></code> and without modifying
the goal state.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.withoutModifyingState" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>