<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="icon" href="../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Std.Data.Internal.List.Associative</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Std.Data.Internal.List.Associative";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Std</span>.<span class="name">Data</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Associative</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Init/Data/BEq.html">Init.Data.BEq</a></li><li><a href="../../../.././Init/Data/List/Find.html">Init.Data.List.Find</a></li><li><a href="../../../.././Init/Data/List/MinMax.html">Init.Data.List.MinMax</a></li><li><a href="../../../.././Init/Data/List/Monadic.html">Init.Data.List.Monadic</a></li><li><a href="../../../.././Init/Data/List/Perm.html">Init.Data.List.Perm</a></li><li><a href="../../../.././Init/Data/Nat/Simproc.html">Init.Data.Nat.Simproc</a></li><li><a href="../../../.././Init/Data/Option/Attach.html">Init.Data.Option.Attach</a></li><li><a href="../../../.././Std/Classes/Ord/Basic.html">Std.Classes.Ord.Basic</a></li><li><a href="../../../.././Std/Data/Internal/List/Defs.html">Std.Data.Internal.List.Defs</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Std.Data.Internal.List.Associative" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.assoc_induction"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">assoc_induction</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_find"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_find</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.beq_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">beq_of_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_eq_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_iff_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_iff_forall_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_iff_forall_isSome_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eq_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_getValueCast?_eq_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_getValueCast?_eq_isSome_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_true_iff_exists_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_true_iff_exists_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_contains_map_fst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_contains_map_fst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_keys_eq_length"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_keys_eq_length</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_keys_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_keys_eq_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_keys_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_keys_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_mem_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_mem_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.def"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">def</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.perm_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">perm_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.distinctKeys_of_sublist_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_of_sublist_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.distinctKeys_of_sublist"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_of_sublist</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.of_keys_eq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">of_keys_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_iff_exists"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_iff_exists</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_false_iff_forall_mem_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_false_iff_forall_mem_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_false_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_false_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.distinctKeys_cons_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_cons_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.tail"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">tail</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_iff_exists_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_iff_forall_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_none</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_none</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_isSome_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_isSome_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getValueCast?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_getValue_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getValue_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_none</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_some_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_getEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_eq_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_eq_of_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_some_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValue</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eq_getEntry_snd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getEntry_snd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eq_some_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCast</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eq_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValueCast</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eq_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_eq_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_getValueCastD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eq_some_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCastD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_eq_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_getValueCast!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eq_some_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCast!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eq_getValueCastD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_getValueCastD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eq_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eq_getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValueD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_some_getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValueD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eq_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_getValueCastD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eq_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eq_getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValue!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_some_getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValue!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eq_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValueCast!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eq_getValueD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValueD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.fst_mem_keys_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">fst_mem_keys_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_isSome_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some_getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eq_getEntry_fst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getEntry_fst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forall_mem_keys_iff_forall_containsKey_getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forall_mem_keys_iff_forall_containsKey_getKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eq_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eq_getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eq_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some_getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eq_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eq_getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eq_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some_getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eq_getKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_getKeyD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_eq_getKey_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_eq_getKey_getValue</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_replaceEntry_of_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_beq_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_replaceEntry_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_key_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_replaceEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_replaceEntry_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_getEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_replaceEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_eraseKey_of_key_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_eraseKey_of_key_beq_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_eraseKey_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_eraseKey_of_key_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.sublist_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">sublist_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_eraseKey_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_eraseKey_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_insertEntry_of_key_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_insertEntry_of_key_beq_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_insertEntry_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_insertEntry_of_key_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertEntry_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntry_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry_of_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_none</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntry_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntryIfNew_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntryIfNew_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntryIfNew_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntryIfNew_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntryIfNew'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertEntryIfNew_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntryIfNew_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_filterMap'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_keys_iff_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_keys_iff_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.keys_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">keys_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_isEmpty_eraseKey_and_not_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_isEmpty_eraseKey_and_not_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_of_isEmpty_eraseKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_of_isEmpty_eraseKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_cons_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_cons_getEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_getValue?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_getValue?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_getValue?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_getValue?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntryIfNew_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_append</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_append</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_flatMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_flatMap_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_append_of_not_contains_right"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_append_of_not_contains_right</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_append</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_append_of_containsKey_left"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_left</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_append_of_containsKey_left_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_left_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_right_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_append_of_not_contains_right"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_append_of_not_contains_right</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_append_of_containsKey_right_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_iff_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getValueCast?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.find?_eq_some_iff_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_eq_some_iff_getValueCast?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.find?_eq_none_iff_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_eq_none_iff_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.pairwise_fst_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">pairwise_fst_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.map_fst_map_toProd_eq_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">map_fst_map_toProd_eq_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.find?_map_eq_none_iff_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_map_eq_none_iff_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_map_toProd_iff_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_iff_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_map_toProd_iff_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_some_iff_exists_beq_and_mem_toList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_iff_exists_beq_and_mem_toList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.pairwise_fst_eq_false_map_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">pairwise_fst_eq_false_map_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldlM_eq_foldlM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldlM_eq_foldlM_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldl_eq_foldl_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldl_eq_foldl_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldrM_eq_foldrM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldrM_eq_foldrM_toProd'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_toProd'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldr_eq_foldr_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldr_eq_foldr_toProd'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_toProd'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forM_eq_forM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forM_eq_forM_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forIn_eq_forIn_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forIn_eq_forIn_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldlM_eq_foldlM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldlM_eq_foldlM_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldl_eq_foldl_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldl_eq_foldl_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldrM_eq_foldrM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldrM_eq_foldrM_keys'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_keys'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldr_eq_foldr_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldr_eq_foldr_keys'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_keys'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forM_eq_forM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forM_eq_forM_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forIn_eq_forIn_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forIn_eq_forIn_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertList_perm_of_perm_first"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList_perm_of_perm_first</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertList_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList_cons_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertList_of_contains_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList_of_contains_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertList_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertList_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Prod.toSigma"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Prod</span>.<span class="name">toSigma</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Prod.fst_comp_toSigma"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Prod</span>.<span class="name">fst_comp_toSigma</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertListConst_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListConst_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertListIfNewUnit_perm_of_perm_first"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListIfNewUnit_perm_of_perm_first</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.mapUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">mapUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertListIfNewUnit_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertListIfNewUnit_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListIfNewUnit_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertListIfNewUnit_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListIfNewUnit_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_list_unit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_list_unit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_alterKey'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_alterKey'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_cons_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_alterKey_eq_isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_alterKey_eq_isEmpty_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_append_of_containsKey_right_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_alterKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_alterKey_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_alterKey_of_key_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_alterKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey_eq_add_one"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_add_one</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey_eq_sub_one"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_sub_one</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey_eq_self'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_self'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_cons_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_alterKey_eq_isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_alterKey_eq_isEmpty_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_append_of_containsKey_right_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_alterKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.mem_alterKey_of_key_not_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">mem_alterKey_of_key_not_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_alterKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.constAlterKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">constAlterKey_eq_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.constAlterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">constAlterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.modifyKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey_eq_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.modifyKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.modifyKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey_eq_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.modifyKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.constModifyKey_eq_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">constModifyKey_eq_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.constModifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">constModifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Option.dmap_bind"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">dmap_bind</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Option.bind_dmap_left"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">bind_dmap_left</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Option.dmap_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">dmap_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Option.map_dmap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">map_dmap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Option.dmap_id"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">dmap_id</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Option.dmap_ite"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">dmap_ite</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Option.get_dmap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">get_dmap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.guard_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">guard_eq_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Sigma.snd_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Sigma</span>.<span class="name">snd_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Option.pmap_eq_dmap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">pmap_eq_dmap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Option.dmap_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">dmap_eq_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Option.any_dmap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">any_dmap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filterMap'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_map'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_map'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filterMap'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.snd_eq_getValueCast_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">snd_eq_getValueCast_of_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eq_getKey_getValue_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eq_getKey_getValue_of_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_apply_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_apply_of_containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_apply_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_apply_of_containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.apply_eq_true_of_containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">apply_eq_true_of_containsKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter_key</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Option.exists_eq_some_and_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">exists_eq_some_and_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filterMap_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filterMap_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filter_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_filterMap_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filterMap_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_filter_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filter_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_eq_get_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_get_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filter_key</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filter_key</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filter_key</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_filterMap_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filterMap_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.key_getValueCast_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">key_getValueCast_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forall_mem_iff_forall_contains_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forall_mem_iff_forall_contains_getValueCast</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_filter_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filter_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_filter_key_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filter_key_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_filter_self_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_self_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_filter_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_self_iff_forall_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_filter_key_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_key_self_iff_forall_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.perm_filter_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">perm_filter_self_iff_forall_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filterMap_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filterMap_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filterMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filterMap_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filter_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filter_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filter_key_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_key_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey_getValue_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_getValue_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.forall_mem_iff_forall_contains_getKey_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">forall_mem_iff_forall_contains_getKey_getValue</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filterMap_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filterMap_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filterMap_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filter_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filter_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filter_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_map_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_map_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_map_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_eq_get_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_eq_get_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_filterMap_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filterMap_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_filter_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filter_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_filter_key_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filter_key_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filterMap_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filterMap_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filterMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filterMap_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filter_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filter_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filter_key_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_key_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filter_key_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_key_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.toList_map'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">toList_map'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.toList_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">toList_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.min_def"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">min_def</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.eq_of_mem_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">eq_of_mem_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.min_eq_or"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">min_eq_or</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.min_eq_left"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">min_eq_left</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.min_eq_left_of_lt"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">min_eq_left_of_lt</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_eq_head?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_head?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_of_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_isEmpty_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_min_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_min_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_some_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_none_iff_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_none_iff_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_of_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_of_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isNone_minEntry?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_minEntry?_eq_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isNone_minKey?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_minKey?_eq_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_eq_not_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_eq_not_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_iff_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_iff_isEmpty_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.min_apply"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">min_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_eq_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_insert"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_insert</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_bind_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_bind_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_bind_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_bind_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eraseKey_eq_iff_beq_minKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eraseKey_eq_iff_beq_minKey?_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eraseKey_eq_of_beq_minKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eraseKey_eq_of_beq_minKey?_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntry_le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry_le_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_of_isSome_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_of_isSome_minKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_le_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_le_minKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_insertIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_insertIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntryIfNew_le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew_le_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_head?_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_head?_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey?_modifyKey_eq_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey_eq_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_minKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_minKey?_modifyKey_eq_isSome"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_minKey?_modifyKey_eq_isSome</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey?_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_get_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_get_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntry_le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry_le_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eraseKey_eq_iff_beq_minKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eraseKey_eq_of_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eraseKey_eq_of_beq_minKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_le_minKey_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_le_minKey_erase</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntryIfNew_le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew_le_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_head_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_head_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey_modifyKey_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey_eq_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_get!_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_get!_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntry_le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry_le_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKey!_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey!_eq_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_iff_beq_minKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_iff_beq_minKey!_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eraseKey_eq_of_beq_minKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_of_beq_minKey!_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_le_minKey!_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_le_minKey!_erase</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntryIfNew_le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew_le_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_head!_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_head!_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey!_modifyKey_eq_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey_eq_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey!_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_getD_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_getD_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_minKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_minKeyD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntry_le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry_le_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKeyD_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKeyD_eq_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_iff_beq_minKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_le_minKeyD_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_le_minKeyD_erase</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntryIfNew_le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew_le_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_headD_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_headD_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKeyD_modifyKey_eq_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey_eq_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKeyD_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_none_iff_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_of_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_of_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isNone_maxKey?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_maxKey?_eq_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_eq_not_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_iff_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_iff_isEmpty_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_bind_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_bind_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_le_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_maxKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_of_isSome_maxKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_of_isSome_maxKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eraseKey_le_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_le_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_le_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_maxKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.reverse_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">reverse_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_getLast?_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_getLast?_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey?_modifyKey_eq_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey_eq_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_maxKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_maxKey?_modifyKey_eq_isSome"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_maxKey?_modifyKey_eq_isSome</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey?_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_get_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_get_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_le_maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le_maxKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_maxKey_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKey_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eraseKey_eq_of_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_eq_of_beq_maxKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eraseKey_le_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_le_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_le_maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le_maxKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_getLast_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_getLast_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey_modifyKey_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey_eq_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_get!_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_get!_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_le_maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le_maxKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_maxKey!_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKey!_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKey!_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey!_eq_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_erase_le_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_erase_le_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_le_maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le_maxKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_getLast!_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_getLast!_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey!_modifyKey_eq_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey_eq_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey!_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_getD_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_getD_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_maxKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_maxKeyD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_le_maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le_maxKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_maxKeyD_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKeyD_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKeyD_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKeyD_eq_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eraseKey_le_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_le_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_le_maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le_maxKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_getLastD_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_getLastD_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKeyD_modifyKey_eq_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey_eq_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKeyD_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_alterKey_eq_self</span></a></div></nav><main>
<div class="mod_doc"><p>This is an internal implementation file of the hash map. Users of the hash map should not rely on
the contents of this file.</p><p>File contents: Verification of associative lists</p></div><div class="decl" id="Std.Internal.List.assoc_induction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L38-L44">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.assoc_induction"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">assoc_induction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <a href="../../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">nil</span> : <span class="fn"><span class="fn">motive</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">cons</span> : <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>) (<span class="fn">tail</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>), <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">tail</span></span> → <span class="fn"><span class="fn">motive</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L46-L49">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">Std.Internal.List.getEntry?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">Std.Internal.List.getEntry?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">Std.Internal.List.getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getEntry?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getEntry?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L51-L52">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L53-L54">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_find"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L56-L60">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_find"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_find</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L62-L64">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L66-L68">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L70-L73">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.beq_of_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L75-L85">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.beq_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">beq_of_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L87-L95">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">b</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_eq_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L97-L101">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_eq_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_some_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L103-L125">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">e</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">e</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_iff_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L127-L129">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_iff_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L131-L134">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_iff_forall_isSome_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L136-L139">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_iff_forall_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_iff_forall_isSome_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L145-L148">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValue?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValue?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L150-L150">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L151-L152">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L154-L156">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L158-L160">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L162-L165">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L167-L174">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L176-L178">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">b</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L180-L182">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L186-L190">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueCast?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueCast?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L192-L193">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L194-L196">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L198-L201">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L203-L205">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L207-L210">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L212-L214">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eq_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L255-L263">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eq_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span> <span class="fn">fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">p</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_getValueCast?_eq_isSome_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L265-L267">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_getValueCast?_eq_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_getValueCast?_eq_isSome_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L269-L271">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L273-L276">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</li></ul></details><details id="instances-for-list-Std.Internal.List.containsKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.containsKey_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L278-L279">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L280-L281">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L283-L285">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L287-L289">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L291-L292">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L294-L296">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L298-L299">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L301-L305">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_isSome_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L307-L314">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_true_iff_exists_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L316-L318">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_true_iff_exists_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_true_iff_exists_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">p</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L320-L322">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_contains_map_fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L324-L331">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_contains_map_fst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_contains_map_fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L333-L333">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></div></div></div></div><div class="decl" id="Std.Internal.List.keys_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L334-L335">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_keys_eq_length"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L337-L338">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_keys_eq_length"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_keys_eq_length</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_keys_eq_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L340-L341">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_keys_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_keys_eq_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_keys_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L343-L347">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_keys_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_keys_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_mem_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L349-L351">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_mem_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_mem_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L353-L355">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L357-L360">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.def"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.perm_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L364-L366">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.perm_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">perm_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l'</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L368-L370">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l'</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L372-L374">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.distinctKeys_of_sublist_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L376-L378">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.distinctKeys_of_sublist_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_of_sublist_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l'</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.distinctKeys_of_sublist"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L380-L382">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.distinctKeys_of_sublist"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_of_sublist</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l'</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.of_keys_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L384-L386">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.of_keys_eq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">of_keys_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_iff_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L388-L390">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_iff_exists"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_iff_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a'</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn">a'</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_false_iff_forall_mem_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L392-L395">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_false_iff_forall_mem_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_false_iff_forall_mem_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a'</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> → (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_false_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L397-L399">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_false_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_false_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><span class="fn">b</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.distinctKeys_cons_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L401-L408">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.distinctKeys_cons_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_cons_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.tail"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L410-L412">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.tail"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">tail</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L414-L416">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L418-L420">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L422-L424">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_iff_exists_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L426-L428">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_iff_exists_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_iff_forall_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L430-L432">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_iff_forall_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_none"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L434-L437">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_none</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_none"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L439-L442">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_none</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_isSome_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L444-L446">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_isSome_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_isSome_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L448-L450">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_isSome_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_getValueCast?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L452-L455">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getValueCast?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_getValue_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L457-L460">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_getValue_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getValue_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eq_none"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L462-L464">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_none</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L466-L468">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">b</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L470-L472">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hla</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L474-L476">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">Std.Internal.List.getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">Std.Internal.List.getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getEntry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_some_getEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L478-L480">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_some_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_getEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_eq_of_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L482-L484">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_eq_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_eq_of_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L486-L488">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L490-L493">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L495-L498">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h₁</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L500-L513">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L515-L530">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L536-L538">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">Std.Internal.List.getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_some_getValue"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L540-L542">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_some_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L544-L546">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L548-L551">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L553-L556">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h₁</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L558-L565">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">v</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L567-L570">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">b</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L572-L583">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eq_getEntry_snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L585-L587">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eq_getEntry_snd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getEntry_snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h'</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L591-L594">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">Std.Internal.List.getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueCast" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eq_some_getValueCast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L596-L598">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eq_some_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L600-L608">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L610-L626">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L628-L643">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eq_getValueCast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L645-L649">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eq_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValueCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L651-L653">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">Std.Internal.List.getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueCastD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueCastD_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L655-L657">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_eq_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L659-L660">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eq_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L662-L666">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_eq_getValueCastD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L668-L671">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_eq_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_getValueCastD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eq_some_getValueCastD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L673-L676">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eq_some_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCastD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L678-L681">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">Std.Internal.List.getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueCast!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueCast!_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L683-L685">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eq_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L687-L688">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L690-L694">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_eq_getValueCast!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L696-L698">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_eq_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_getValueCast!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eq_some_getValueCast!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L700-L703">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eq_some_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCast!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eq_getValueCastD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L705-L706">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eq_getValueCastD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_getValueCastD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L712-L714">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">Std.Internal.List.getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueD_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L716-L718">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eq_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L720-L721">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eq_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L723-L726">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eq_getValueD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L728-L730">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eq_getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValueD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_some_getValueD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L732-L734">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_some_getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValueD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eq_getValueCastD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L736-L738">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eq_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_getValueCastD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L740-L742">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">b</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L744-L746">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">Std.Internal.List.getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValue!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValue!_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L748-L750">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eq_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L752-L753">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eq_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L755-L758">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eq_getValue!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L760-L762">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eq_getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValue!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_some_getValue!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L764-L766">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_some_getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValue!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eq_getValueCast!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L768-L770">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eq_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValueCast!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L772-L774">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">b</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eq_getValueD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L776-L777">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eq_getValueD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValueD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L781-L784">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getKey?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getKey?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L786-L787">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L789-L790">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L792-L794">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L796-L798">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L800-L807">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.fst_mem_keys_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L809-L811">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.fst_mem_keys_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">fst_mem_keys_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hm</span> : <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L813-L823">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L825-L831">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.all">Option.all</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L833-L838">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_isSome_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L840-L842">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_isSome_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L844-L854">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L856-L862">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L864-L866">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">Std.Internal.List.getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some_getKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L868-L870">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some_getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L872-L879">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L881-L883">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L885-L888">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L890-L892">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L894-L896">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h''</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">h''</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L898-L928">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eq_getEntry_fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L930-L932">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eq_getEntry_fst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getEntry_fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.forall_mem_keys_iff_forall_containsKey_getKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L934-L969">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forall_mem_keys_iff_forall_containsKey_getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forall_mem_keys_iff_forall_containsKey_getKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">k</span></span></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">p</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L971-L973">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">Std.Internal.List.getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getKeyD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getKeyD_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L975-L977">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eq_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L979-L980">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eq_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L982-L986">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eq_getKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L988-L991">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eq_getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L993-L995">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eq_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L997-L1000">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eq_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some_getKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1002-L1005">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some_getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1007-L1009">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">Std.Internal.List.getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getKey!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getKey!_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1011-L1013">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eq_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1015-L1016">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eq_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1018-L1022">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eq_getKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1024-L1026">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eq_getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1028-L1030">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eq_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1032-L1035">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eq_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some_getKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1037-L1040">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some_getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eq_getKeyD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1042-L1043">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eq_getKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_getKeyD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1045-L1056">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_eq_getKey_getValue"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1058-L1069">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_eq_getKey_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_eq_getKey_getValue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1071-L1074">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k_1</span>, <span class="fn">v_1</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">bif <span class="fn">k_1</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span> then <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k_1</span>, <span class="fn">v_1</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.replaceEntry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.replaceEntry_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1076-L1076">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1077-L1079">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span> then <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1081-L1083">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1085-L1088">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1090-L1096">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1098-L1104">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_replaceEntry_of_beq_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1106-L1119">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_replaceEntry_of_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_beq_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_replaceEntry_of_key_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1121-L1124">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_replaceEntry_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_key_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_replaceEntry_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1126-L1129">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_replaceEntry_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1131-L1141">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_replaceEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_replaceEntry_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1143-L1154">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1156-L1164">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1166-L1173">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_replaceEntry_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1175-L1180">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_replaceEntry_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">hl</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.mem_getEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1182-L1191">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_getEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">hl</span></span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_replaceEntry_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1193-L1199">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1201-L1204">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_replaceEntry_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1210-L1212">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_replaceEntry_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1214-L1217">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_replaceEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_replaceEntry_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1219-L1222">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1226-L1240">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1242-L1252">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1254-L1257">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k_1</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k_1</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span> then <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k_1</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.eraseKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.eraseKey_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1259-L1259">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1261-L1262">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span> then <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1264-L1266">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1268-L1271">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1273-L1275">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1277-L1283">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_eraseKey_of_key_beq_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1285-L1300">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_eraseKey_of_key_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_eraseKey_of_key_beq_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_eraseKey_of_key_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1302-L1304">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_eraseKey_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_eraseKey_of_key_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.sublist_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1306-L1314">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.sublist_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">sublist_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1316-L1331">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_eraseKey_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1333-L1335">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_eraseKey_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_eraseKey_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1337-L1340">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1342-L1347">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1349-L1361">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1363-L1373">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hk</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkv</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1375-L1377">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">Std.Internal.List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">bif <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> then <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertEntry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.insertEntry_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1379-L1382">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.cons">[</a><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a><a href="../../../.././Init/Prelude.html#List.cons">]</a></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1384-L1390">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>))</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span>)</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1392-L1394">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1396-L1399">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1401-L1403">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1405-L1407">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_insertEntry_of_key_beq_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1409-L1417">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_insertEntry_of_key_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_insertEntry_of_key_beq_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_insertEntry_of_key_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1419-L1422">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_insertEntry_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_insertEntry_of_key_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1424-L1430">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1432-L1437">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1439-L1441">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1443-L1446">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertEntry_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1448-L1451">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertEntry_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntry_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1457-L1461">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry_of_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1463-L1465">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry_of_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1467-L1471">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1473-L1477">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1479-L1481">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1485-L1490">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1492-L1498">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1500-L1502">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1504-L1507">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1509-L1511">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1513-L1518">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1520-L1522">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1524-L1527">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1529-L1531">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1533-L1536">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1538-L1540">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1542-L1547">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1549-L1551">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_none"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1553-L1555">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_none</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1557-L1560">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1562-L1564">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1566-L1569">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1571-L1573">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1575-L1579">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntry_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1581-L1583">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntry_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1585-L1587">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1589-L1592">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1594-L1600">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1602-L1604">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1606-L1612">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">v</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1614-L1616">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1618-L1623">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1625-L1627">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntryIfNew"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1629-L1631">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">Std.Internal.List.insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> then <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertEntryIfNew" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.insertEntryIfNew_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1633-L1635">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntryIfNew_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1637-L1639">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1641-L1649">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">List.insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1651-L1657">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1659-L1664">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1666-L1673">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1675-L1679">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1681-L1692">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntryIfNew_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1694-L1696">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntryIfNew_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntryIfNew_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1698-L1701">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1703-L1713">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntryIfNew'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <a href="../../../.././Init/Prelude.html#Not">¬</a>((<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>))</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div><p>This is a restatement of <code><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntryIfNew">containsKey_insertEntryIfNew</a></code> that is written to exactly match the proof
obligation in the statement of <code><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertEntryIfNew">getValueCast_insertEntryIfNew</a></code>.</p></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1715-L1723">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1725-L1731">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn">v</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1733-L1737">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1739-L1742">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1744-L1749">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1751-L1755">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1757-L1763">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1765-L1771">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1773-L1776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1778-L1781">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1783-L1785">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1787-L1790">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertEntryIfNew_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1792-L1795">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertEntryIfNew_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntryIfNew_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1797-L1805">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.erase">erase</a></span> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1807-L1809">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">List.eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1811-L1821">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eraseKey_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1823-L1825">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eraseKey_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1827-L1839">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1841-L1846">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_filterMap'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1848-L1855">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_filterMap'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_keys_iff_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1857-L1863">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_keys_iff_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_keys_iff_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.keys_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1865-L1885">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <a href="../../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Subtype">//</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Subtype">}</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Subtype.val">val</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Subtype.val">val</a></span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span>)</span> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Attach.html#List.attach">attach</a></span>)</span>.<a href="../../../.././Init/Data/List/Attach.html#List.unattach">unattach</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.keys_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1887-L1907">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.keys_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">keys_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <a href="../../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Subtype">//</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Subtype">}</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Subtype.val">val</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Subtype.val">val</a></span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span>)</span> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Attach.html#List.attach">attach</a></span>)</span>.<a href="../../../.././Init/Data/List/Attach.html#List.unattach">unattach</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1909-L1912">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1914-L1920">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1922-L1924">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1926-L1928">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1934-L1936">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eraseKey_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1938-L1940">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eraseKey_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1942-L1944">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1946-L1949">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1953-L1959">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1961-L1963">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1965-L1968">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1970-L1972">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1974-L1977">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1979-L1981">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1983-L1985">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eraseKey_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1987-L1989">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eraseKey_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1991-L1993">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1995-L1997">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_isEmpty_eraseKey_and_not_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L1999-L2012">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_isEmpty_eraseKey_and_not_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_isEmpty_eraseKey_and_not_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_of_isEmpty_eraseKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2014-L2018">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_of_isEmpty_eraseKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_of_isEmpty_eraseKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2020-L2026">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2028-L2030">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2032-L2035">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2037-L2039">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2041-L2045">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2047-L2050">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2052-L2055">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2057-L2060">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2062-L2065">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2067-L2070">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2072-L2074">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2076-L2081">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2083-L2088">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2090-L2095">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2097-L2111">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2113-L2121">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2123-L2125">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2127-L2131">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2133-L2136">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2138-L2141">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2147-L2149">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2151-L2155">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2157-L2159">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2161-L2164">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2168-L2170">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2172-L2176">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2178-L2181">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2183-L2186">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_cons_getEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2188-L2198">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_cons_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_cons_getEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">l'</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l'</span>)</span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2201-L2219">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2221-L2225">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_getValue?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2227-L2243">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_getValue?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_getValue?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hk</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>) (<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">h'</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hv</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_getValue?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2245-L2251">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_getValue?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_getValue?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hk</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hv</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2253-L2265">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2267-L2274">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2276-L2279">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2281-L2284">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntryIfNew_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2286-L2290">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2292-L2295">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_append"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2297-L2302">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_append</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.or">or</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2304-L2306">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_append"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2308-L2311">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_append</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_flatMap_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2313-L2324">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_flatMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_flatMap_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">i</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>) (<span class="fn">h</span> : <span class="fn">i</span> <a href="../../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<span class="fn">f</span> <span class="fn">l</span><a href="../../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../../.././Init/GetElem.html#GetElem.getElem">]</a>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.flatMap">List.flatMap</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_append_of_not_contains_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2326-L2328">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_append_of_not_contains_right"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_append_of_not_contains_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_append"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2330-L2333">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_append</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.or">or</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2335-L2337">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2339-L2343">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>) <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2345-L2348">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2350-L2355">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2357-L2360">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2362-L2367">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_append_of_containsKey_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2369-L2377">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_append_of_containsKey_left"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_append_of_containsKey_left_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2379-L2386">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_append_of_containsKey_left_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_left_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_append_of_containsKey_right_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2388-L2394">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_right_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_append_of_not_contains_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2396-L2401">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_append_of_not_contains_right"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_append_of_not_contains_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_append_of_containsKey_right_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2403-L2411">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_append_of_containsKey_right_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_iff_getValueCast?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2413-L2422">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_iff_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getValueCast?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.find?_eq_some_iff_getValueCast?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2424-L2428">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.find?_eq_some_iff_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_eq_some_iff_getValueCast?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.find?_eq_none_iff_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2430-L2433">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.find?_eq_none_iff_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_eq_none_iff_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.pairwise_fst_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2435-L2438">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.pairwise_fst_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">pairwise_fst_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.map_fst_map_toProd_eq_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2440-L2446">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.map_fst_map_toProd_eq_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">map_fst_map_toProd_eq_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.find?_map_eq_none_iff_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2448-L2452">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.find?_map_eq_none_iff_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_map_eq_none_iff_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.mem_map_toProd_iff_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2454-L2462">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_map_toProd_iff_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_iff_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2464-L2474">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_iff_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_map_toProd_iff_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2476-L2480">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_map_toProd_iff_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2482-L2495">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k'</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_iff_getKey?_eq_some_and_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2497-L2500">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_some_iff_exists_beq_and_mem_toList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2502-L2516">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_some_iff_exists_beq_and_mem_toList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_iff_exists_beq_and_mem_toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k'</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k'</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2519-L2523">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.pairwise_fst_eq_false_map_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2525-L2530">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.pairwise_fst_eq_false_map_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">pairwise_fst_eq_false_map_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldlM_eq_foldlM_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2532-L2538">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldlM_eq_foldlM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldlM_eq_foldlM_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldlM">List.foldlM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldlM">List.foldlM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldl_eq_foldl_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2540-L2546">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldl_eq_foldl_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldl_eq_foldl_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldrM_eq_foldrM_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2548-L2554">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldrM_eq_foldrM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldrM_eq_foldrM_toProd'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2556-L2562">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldrM_eq_foldrM_toProd'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_toProd'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldr_eq_foldr_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2564-L2570">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldr_eq_foldr_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldr_eq_foldr_toProd'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2572-L2578">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldr_eq_foldr_toProd'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_toProd'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.forM_eq_forM_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2580-L2585">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forM_eq_forM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forM_eq_forM_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m'</span> <a href="../../../.././Init/Prelude.html#PUnit">PUnit</a></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../../.././Init/Control/Basic.html#ForM.forM">forM</a> <span class="fn">l</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Control/Basic.html#ForM.forM">forM</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.forIn_eq_forIn_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2587-L2593">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forIn_eq_forIn_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forIn_eq_forIn_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">(<a href="../../../.././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">δ</span>)</span></span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">l</span> <span class="fn">init</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">d</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <span class="fn">d</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span> <span class="fn">init</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">d</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span> <span class="fn">d</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldlM_eq_foldlM_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2595-L2603">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldlM_eq_foldlM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldlM_eq_foldlM_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldlM">List.foldlM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldlM">List.foldlM</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldl_eq_foldl_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2605-L2610">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldl_eq_foldl_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldl_eq_foldl_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">δ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldrM_eq_foldrM_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2612-L2618">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldrM_eq_foldrM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldrM_eq_foldrM_keys'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2620-L2626">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldrM_eq_foldrM_keys'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_keys'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn">a</span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldr_eq_foldr_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2628-L2633">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldr_eq_foldr_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn">δ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldr_eq_foldr_keys'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2635-L2640">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldr_eq_foldr_keys'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_keys'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">δ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn">a</span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.forM_eq_forM_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2642-L2651">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forM_eq_forM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forM_eq_forM_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m'</span> <a href="../../../.././Init/Prelude.html#PUnit">PUnit</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Control.html#List.forM">forM</a></span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Control.html#List.forM">forM</a></span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.forIn_eq_forIn_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2653-L2662">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forIn_eq_forIn_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forIn_eq_forIn_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">(<a href="../../../.././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">δ</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">l</span> <span class="fn">init</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">d</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">d</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span> <span class="fn">init</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2664-L2668">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">Std.Internal.List.insertList</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">Std.Internal.List.insertList</a> <span class="fn">l</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l_1</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">Std.Internal.List.insertList</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">Std.Internal.List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">l_1</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2670-L2677">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">List.insertList</a> <span class="fn">l₁</span> <span class="fn">l₂</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertList_perm_of_perm_first"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2679-L2686">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList_perm_of_perm_first"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList_perm_of_perm_first</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l1 </span><span class="fn">l2 </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l1</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l2</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l1</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l2</span> <span class="fn">toInsert</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertList_cons_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2688-L2706">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList_cons_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₂</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<span class="fn">p</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l₂</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l₁</span> (<span class="fn">p</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l₂</span>))</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l₁</span> <span class="fn">l₂</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2708-L2723">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.or">or</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2725-L2735">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">toInsert</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertList_of_contains_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2737-L2745">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertList_of_contains_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList_of_contains_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">contains</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">toInsert</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">toInsert</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2747-L2759">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2761-L2764">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2766-L2772">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2774-L2789">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2791-L2799">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2801-L2811">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2813-L2818">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2820-L2829">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k'</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2831-L2836">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_mem</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2838-L2847">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2849-L2855">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2857-L2867">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2869-L2876">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2878-L2887">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2889-L2893">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains_false</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2895-L2903">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2905-L2909">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2911-L2919">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2921-L2938">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_both</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">toInsert</span>)</span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2940-L2946">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_both</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2948-L2953">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertList_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2955-L2964">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertList_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertList_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2966-L2973">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.Prod.toSigma"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2979-L2980">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.toSigma"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Prod</span>.<span class="name">toSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.toSigma">Std.Internal.List.Prod.toSigma</a> <span class="fn">p</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>, <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></li></ul></details><details id="instances-for-list-Std.Internal.List.Prod.toSigma" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.Prod.fst_comp_toSigma"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2982-L2986">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.fst_comp_toSigma"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Prod</span>.<span class="name">fst_comp_toSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <a href="../../../.././Init/Prelude.html#Function.comp">∘</a> <a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.toSigma">toSigma</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a></div></div></div></div><div class="decl" id="Std.Internal.List.insertListConst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2988-L2990">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">Std.Internal.List.insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">Std.Internal.List.insertList</a> <span class="fn">l</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.toSigma">Std.Internal.List.Prod.toSigma</a> <span class="fn">toInsert</span>)</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertListConst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.containsKey_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L2992-L2998">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3000-L3006">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3008-L3014">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3016-L3027">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3029-L3036">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3038-L3047">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3049-L3054">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3056-L3064">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3066-L3071">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3073-L3081">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3083-L3093">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_both</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3095-L3100">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertListConst_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3102-L3107">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertListConst_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListConst_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3109-L3114">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3116-L3123">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3125-L3150">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3152-L3159">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3161-L3170">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3172-L3177">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3179-L3187">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3189-L3194">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3196-L3204">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v </span><span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertListIfNewUnit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3206-L3211">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">Std.Internal.List.insertListIfNewUnit</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">Std.Internal.List.insertListIfNewUnit</a> <span class="fn">l</span> (<span class="fn">hd</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">tl</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">Std.Internal.List.insertListIfNewUnit</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">Std.Internal.List.insertEntryIfNew</a> <span class="fn">hd</span> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a> <span class="fn">l</span>)</span> <span class="fn">tl</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertListIfNewUnit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.insertListIfNewUnit_perm_of_perm_first"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3213-L3229">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit_perm_of_perm_first"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListIfNewUnit_perm_of_perm_first</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l1 </span><span class="fn">l2</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l1</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l2</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l1</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l2</span> <span class="fn">toInsert</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3231-L3238">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">List.insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3240-L3260">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.or">or</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">x</span>, <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">toInsert</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.mapUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3262-L3267">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.mapUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">mapUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">x</span>, <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertListIfNewUnit_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3269-L3282">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertListIfNewUnit_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertListIfNewUnit_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3284-L3292">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3294-L3299">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3301-L3307">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3309-L3325">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListIfNewUnit_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3327-L3333">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertListIfNewUnit_of_contains_eq_false_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3335-L3343">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertListIfNewUnit_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3345-L3351">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListIfNewUnit_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">contains</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3353-L3360">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false'</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3362-L3369">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListIfNewUnit_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3371-L3376">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3378-L3384">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false'</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3386-L3393">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3395-L3401">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3403-L3446">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_both</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3448-L3453">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertListIfNewUnit_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3455-L3465">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertListIfNewUnit_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListIfNewUnit_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3467-L3474">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_list_unit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3476-L3484">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_list_unit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_list_unit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3486-L3490">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.alterKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3509-L3514">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">Std.Internal.List.alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">Std.Internal.List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.alterKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.length_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3516-L3524">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>
  else <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Option.none">none</a>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_alterKey'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3526-L3535">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_alterKey'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_alterKey'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>
  <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.alterKey_cons_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3537-L3555">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_cons_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>))</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span>
  <span class="fn">(if hk : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then
    <span class="fn">match <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v'</span>)</span>)</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn">l</span>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></span>
  else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_alterKey_eq_isEmpty_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3557-L3562">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_alterKey_eq_isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_alterKey_eq_isEmpty_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3564-L3567">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> ((<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.alterKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3569-L3574">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.alterKey_append_of_containsKey_right_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3576-L3581">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_append_of_containsKey_right_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.alterKey_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3583-L3587">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">b</span></span> =&gt; <a href="../../../.././Init/Prelude.html#List.cons">[</a><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn">b</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a><a href="../../../.././Init/Prelude.html#List.cons">]</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_alterKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3589-L3600">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_alterKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3602-L3616">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3618-L3623">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">List.alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_alterKey_of_key_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3625-L3629">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_alterKey_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_alterKey_of_key_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3631-L3654">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3656-L3676">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_alterKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3678-L3684">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_alterKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3686-L3697">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k'</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3699-L3706">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span>
  else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3708-L3716">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3718-L3730">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3732-L3750">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3752-L3763">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3773-L3778">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">Std.Internal.List.Const.alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">Std.Internal.List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.Const.alterKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3780-L3788">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>
  else <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Option.none">none</a>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3790-L3799">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>
  <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey_eq_add_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3801-L3804">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey_eq_add_one"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_add_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey_eq_sub_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3806-L3809">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey_eq_sub_one"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_sub_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3811-L3814">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey_eq_self'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3816-L3819">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey_eq_self'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_self'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey_cons_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3821-L3840">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_cons_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>))</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span>
  (<a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a>
    <span class="fn">match <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v'</span>)</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn">l</span>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></span>
  <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span>)</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_alterKey_eq_isEmpty_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3842-L3846">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_alterKey_eq_isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_alterKey_eq_isEmpty_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3848-L3851">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> ((<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3853-L3859">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey_append_of_containsKey_right_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3861-L3866">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_append_of_containsKey_right_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3868-L3872">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">b</span></span> =&gt; <a href="../../../.././Init/Prelude.html#List.cons">[</a><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn">b</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a><a href="../../../.././Init/Prelude.html#List.cons">]</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_alterKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3874-L3887">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_alterKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.mem_alterKey_of_key_not_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3889-L3894">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.mem_alterKey_of_key_not_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">mem_alterKey_of_key_not_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3896-L3913">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3915-L3936">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3938-L3956">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_alterKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3958-L3963">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_alterKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3965-L3973">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3975-L3983">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3985-L3993">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L3995-L4002">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4004-L4021">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4023-L4034">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.constAlterKey_eq_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4038-L4041">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.constAlterKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">constAlterKey_eq_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">Const.alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.constAlterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4043-L4049">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.constAlterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">constAlterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">Const.alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.modifyKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4055-L4060">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">Std.Internal.List.modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn">l</span>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">(<span class="fn">f</span> <span class="fn">v</span>)</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.modifyKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.isEmpty_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4062-L4068">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4070-L4076">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4078-L4085">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.modifyKey_eq_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4087-L4091">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey_eq_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">x</span></span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4093-L4095">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">List.modifyKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.modifyKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4097-L4100">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4102-L4109">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4111-L4115">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4117-L4132">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4134-L4139">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4141-L4148">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">hi</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k'</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4150-L4154">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4156-L4163">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span>
  else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4165-L4169">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4171-L4178">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4180-L4183">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4185-L4192">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4194-L4197">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4199-L4207">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4209-L4213">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4215-L4222">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4224-L4227">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.modifyKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4233-L4238">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">Std.Internal.List.Const.modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn">l</span>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">(<span class="fn">f</span> <span class="fn">v</span>)</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.Const.modifyKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4240-L4246">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.modifyKey_eq_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4248-L4252">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey_eq_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">x</span></span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.modifyKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4254-L4257">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4259-L4265">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4267-L4274">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4276-L4283">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4285-L4288">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4290-L4304">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4306-L4311">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4313-L4319">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">hi</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4321-L4325">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4327-L4334">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4336-L4340">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4342-L4349">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4351-L4354">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4356-L4362">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4364-L4367">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4369-L4378">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4380-L4384">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4386-L4393">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4395-L4398">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.constModifyKey_eq_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4402-L4406">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.constModifyKey_eq_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">constModifyKey_eq_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">Const.modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.constModifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4408-L4410">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.constModifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">constModifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">Const.modifyKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Option.dmap_bind"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4416-L4420">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Option.dmap_bind"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">dmap_bind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">β</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">f</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">(<span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">f</span>)</span> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pbind">pbind</a></span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span>) =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">fun (<span class="fn">b</span> : <span class="fn">β</span>) (<span class="fn">h'</span> : <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">b</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">b</span> <span class="fn">⋯</span></span></span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Option.bind_dmap_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4422-L4425">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Option.bind_dmap_left"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">bind_dmap_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">x</span> <span class="fn">f</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pbind">pbind</a></span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span> <span class="fn">h</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Option.dmap_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4427-L4430">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Option.dmap_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">dmap_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">β</span>) → <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">x</span>)</span> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">x</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Option.map_dmap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4432-L4435">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Option.map_dmap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">map_dmap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">g</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">x</span> <span class="fn">f</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">x</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span> <span class="fn">h</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Option.dmap_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4437-L4438">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Option.dmap_id"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">dmap_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">x</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">x</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span>) =&gt; <span class="fn">a</span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></div></div></div></div><div class="decl" id="Std.Internal.List.Option.dmap_ite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4440-L4449">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Option.dmap_ite"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">dmap_ite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t </span><span class="fn">e</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">t</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">e</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> (<a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">t</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">e</span>) <span class="fn">f</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn">p</span> then <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">t</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h'</span> : <span class="fn">t</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span></span>
  else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">e</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h'</span> : <span class="fn">e</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Option.get_dmap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4451-L4454">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Option.get_dmap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">get_dmap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span> → <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">x</span> <span class="fn">f</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">x</span> <span class="fn">f</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.guard_eq_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4456-L4459">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.guard_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">guard_eq_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.guard">Option.guard</a> <span class="fn">fun (<span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn">p</span> <span class="fn">b</span>)</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt;
  <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">y</span> : <span class="fn"><span class="fn">β</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">y</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> (<a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Sigma.snd_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4461-L4463">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Sigma.snd_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Sigma</span>.<span class="name">snd_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">x'</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn"><span class="fn">x'</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Option.pmap_eq_dmap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4465-L4468">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Option.pmap_eq_dmap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">pmap_eq_dmap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">x</span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/Option/Instances.html#Option.pmap">Option.pmap</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">x</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h'</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Option.dmap_eq_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4470-L4472">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Option.dmap_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">dmap_eq_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">x</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">x</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Option.any_dmap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4474-L4477">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Option.any_dmap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">any_dmap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span> → <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.any">Option.any</a> <span class="fn">p</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#_private.Std.Data.Internal.List.Associative.0.Std.Internal.List.Option.dmap">Std.Internal.List.Option.dmap✝</a> <span class="fn">x</span> <span class="fn">f</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.any">Option.any</a>
    <span class="fn">(fun (<span class="fn">x_1</span> : <a href="../../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">x_1</span> <a href="../../../.././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Subtype">//</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x_1</span></span> <a href="../../../.././Init/Prelude.html#Subtype">}</a>) =&gt;
      <span class="fn">match <span class="fn">x_1</span> with
      | <a href="../../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">a</span>, <span class="fn">h</span><a href="../../../.././Init/Prelude.html#Subtype.mk">⟩</a> =&gt; <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span> <span class="fn">h</span>)</span></span></span>)</span>
    <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Data/Option/Attach.html#Option.attach">attach</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_filterMap'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4479-L4503">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filterMap'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.all">Option.all</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">p</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_map'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4505-L4510">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_map'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_map'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), (<span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">p</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4512-L4518">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4520-L4527">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4529-L4536">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_filterMap'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4538-L4546">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filterMap'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.all">Option.all</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">p</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4548-L4555">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.snd_eq_getValueCast_of_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4557-L4565">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.snd_eq_getValueCast_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">snd_eq_getValueCast_of_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">y</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eq_getKey_getValue_of_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4567-L4573">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eq_getKey_getValue_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eq_getKey_getValue_of_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_apply_of_containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4575-L4584">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_apply_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_apply_of_containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_apply_of_containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4586-L4595">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_apply_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_apply_of_containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4597-L4605">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4607-L4621">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> else <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4623-L4637">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> else <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4639-L4644">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.apply_eq_true_of_containsKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4646-L4656">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.apply_eq_true_of_containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">apply_eq_true_of_containsKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4658-L4667">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4669-L4674">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4676-L4681">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4683-L4694">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4696-L4701">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4703-L4708">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4710-L4719">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4721-L4726">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4728-L4733">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4735-L4741">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4743-L4748">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4750-L4755">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4757-L4762">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.any">Option.any</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">x</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4764-L4769">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.any">Option.any</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filter_key"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4771-L4776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter_key</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Option.exists_eq_some_and_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4778-L4780">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Option.exists_eq_some_and_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">exists_eq_some_and_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn">o</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>) <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">o</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn"><span class="fn">o</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filterMap_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4782-L4788">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filterMap_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filterMap_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filter_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4790-L4796">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filter_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_filterMap_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4798-L4807">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_filterMap_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filterMap_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_filter_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4809-L4816">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_filter_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filter_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4818-L4831">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4833-L4839">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4841-L4847">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_eq_get_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4849-L4852">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_eq_get_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_get_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4854-L4865">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_filter_key"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4867-L4884">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filter_key</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4886-L4892">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_filter_key"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4894-L4897">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filter_key</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4899-L4905">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_filter_key"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4907-L4910">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filter_key</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4912-L4915">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4917-L4920">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4922-L4925">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4927-L4930">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4932-L4936">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4938-L4942">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4944-L4951">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4953-L4961">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4963-L4968">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_filterMap_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4970-L4985">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_filterMap_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filterMap_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.key_getValueCast_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L4987-L4998">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.key_getValueCast_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">key_getValueCast_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.forall_mem_iff_forall_contains_getValueCast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5000-L5010">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forall_mem_iff_forall_contains_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forall_mem_iff_forall_contains_getValueCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_filter_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5012-L5017">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_filter_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filter_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_filter_key_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5019-L5033">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_filter_key_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filter_key_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_filter_self_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5035-L5039">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_filter_self_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_self_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_filter_self_iff_forall_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5041-L5050">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_filter_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_self_iff_forall_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_filter_key_self_iff_forall_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5052-L5063">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_filter_key_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_key_self_iff_forall_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.perm_filter_self_iff_forall_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5065-L5077">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.perm_filter_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">perm_filter_self_iff_forall_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filterMap_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5079-L5084">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filterMap_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filterMap_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filterMap_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5086-L5091">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filterMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filterMap_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filter_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5093-L5098">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filter_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filter_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5100-L5105">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filter_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filter_key_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5107-L5120">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filter_key_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_key_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey_getValue_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5124-L5133">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey_getValue_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_getValue_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span></span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.forall_mem_iff_forall_contains_getKey_getValue"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5135-L5146">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.forall_mem_iff_forall_contains_getKey_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">forall_mem_iff_forall_contains_getKey_getValue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>), <span class="fn"><span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">p</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5148-L5158">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pbind">pbind</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_filterMap_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5160-L5169">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filterMap_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5171-L5176">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pbind">pbind</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_filterMap_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5178-L5185">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filterMap_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5187-L5192">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">γ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pbind">pbind</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_filterMap_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5194-L5201">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filterMap_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
      <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5203-L5214">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_filter_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5216-L5225">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filter_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5227-L5232">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_filter_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5234-L5240">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filter_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5242-L5247">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_filter_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5249-L5254">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filter_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5256-L5264">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/Option/Instances.html#Option.pmap">Option.pmap</a> <span class="fn">(fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">v</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_map_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5266-L5270">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_map_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k'</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5272-L5277">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Instances.html#Option.pmap">Option.pmap</a> <span class="fn">(fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">v</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_map_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5279-L5283">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_map_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k'</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5285-L5290">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">γ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Instances.html#Option.pmap">Option.pmap</a> <span class="fn">(fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">v</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_map_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5292-L5296">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_map_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k'</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5298-L5311">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5313-L5319">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5321-L5327">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_eq_get_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5329-L5332">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_eq_get_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_eq_get_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5334-L5344">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5346-L5352">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5354-L5360">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_filterMap_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5362-L5377">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_filterMap_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filterMap_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_filter_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5379-L5384">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_filter_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filter_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_filter_key_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5386-L5391">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_filter_key_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filter_key_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filterMap_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5393-L5398">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filterMap_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filterMap_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filterMap_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5400-L5405">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filterMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filterMap_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filter_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5407-L5412">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filter_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filter_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5414-L5419">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filter_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filter_key_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5421-L5425">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filter_key_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_key_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filter_key_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5427-L5431">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filter_key_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_key_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.toList_map'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5433-L5436">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.toList_map'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">toList_map'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">γ</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.toList_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5438-L5441">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.toList_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">toList_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span>
  <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">γ</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.min_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5464-L5466">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.min_def"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">min_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Min.min">min</a> <span class="fn">p</span> <span class="fn">q</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">q</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">q</span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5481-L5483">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Like <code><a href="../../../.././Init/Data/List/Basic.html#List.min?">List.min?</a></code>, but using an <code><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a></code> typeclass instead of a <code><a href="../../../.././Init/Prelude.html#Min">Min</a></code> typeclass.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">Std.Internal.List.minEntry?</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">xs</span>.<a href="../../../.././Init/Data/List/Basic.html#List.min?">min?</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minEntry?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.minKey?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5485-L5487">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></div></div><p>Returns the smallest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">Std.Internal.List.minEntry?</a> <span class="fn">xs</span>)</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minKey?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.eq_of_mem_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5489-L5501">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.eq_of_mem_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">eq_of_mem_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hma</span> : <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hmb</span> : <span class="fn">b</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Std.Internal.List.min_eq_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5503-L5505">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.min_eq_or"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">min_eq_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Min.min">min</a> <span class="fn">p</span> <span class="fn">q</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Min.min">min</a> <span class="fn">p</span> <span class="fn">q</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></div></div></div></div><div class="decl" id="Std.Internal.List.min_eq_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5507-L5508">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.min_eq_left"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">min_eq_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">q</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Min.min">min</a> <span class="fn">p</span> <span class="fn">q</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">p</span></div></div></div></div><div class="decl" id="Std.Internal.List.min_eq_left_of_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5510-L5511">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.min_eq_left_of_lt"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">min_eq_left_of_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">q</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Min.min">min</a> <span class="fn">p</span> <span class="fn">q</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">p</span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_eq_head?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5513-L5515">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_eq_head?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_head?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.head?">head?</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5517-L5519">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5521-L5526">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> (<span class="fn">e</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a>
    <span class="fn">(match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn">e</span>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">w</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Min.min">min</a> <span class="fn">e</span> <span class="fn">w</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_of_isEmpty_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5528-L5532">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_of_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_isEmpty_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_min_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5534-L5541">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_min_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_min_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Min.min">min</a> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_eq_some_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5543-L5558">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_some_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">b</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5560-L5569">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5571-L5583">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5585-L5593">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5595-L5598">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_eq_none_iff_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5600-L5602">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_none_iff_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_none_iff_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5604-L5606">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_none_iff_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_of_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5608-L5610">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_of_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_of_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.isNone_minEntry?_eq_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5612-L5615">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isNone_minEntry?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_minEntry?_eq_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isNone_minKey?_eq_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5617-L5619">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isNone_minKey?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_minKey?_eq_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_eq_not_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5621-L5625">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_eq_not_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_eq_not_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5627-L5629">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_eq_not_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_iff_isEmpty_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5631-L5633">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_iff_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_iff_isEmpty_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.min_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5635-L5638">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.min_apply"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">min_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e₁ </span><span class="fn">e₂</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">e₁</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">e₂</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">e₁</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">e₂</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Min.min">min</a> <span class="fn">(<span class="fn">f</span> <span class="fn">e₁</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">e₂</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Min.min">min</a> <span class="fn">e₁</span> <span class="fn">e₂</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5640-L5651">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">e₁ </span><span class="fn">e₂</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">e₁</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">e₂</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">e₁</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">e₂</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_eq_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5653-L5672">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_eq_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">e</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">e</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5674-L5684">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">e</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">e</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5686-L5692">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5694-L5714">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a>
    <span class="fn">(match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">w</span></span> =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn"><span class="fn">w</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">w</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5716-L5721">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_insert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5723-L5726">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_insert"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_insert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5728-L5731">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5733-L5736">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5738-L5741">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5743-L5747">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">em</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hem</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">em</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn"><span class="fn">em</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">em</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_bind_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5749-L5755">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_bind_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_bind_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">k</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5757-L5760">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5771-L5776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">km</span> <span class="fn">l</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5778-L5782">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5784-L5788">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">km</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_bind_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5790-L5795">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_bind_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_bind_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">k</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5797-L5802">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eraseKey_eq_iff_beq_minKey?_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5804-L5811">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eraseKey_eq_iff_beq_minKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eraseKey_eq_iff_beq_minKey?_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ {<span class="fn">km</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> → (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eraseKey_eq_of_beq_minKey?_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5813-L5819">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eraseKey_eq_of_beq_minKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eraseKey_eq_of_beq_minKey?_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn">∀ {<span class="fn">km</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> → (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntry_le_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5821-L5826">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntry_le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry_le_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">kmi</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntry_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5828-L5836">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">kmi</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5838-L5843">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5845-L5855">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_of_isSome_minKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5857-L5860">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_of_isSome_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_of_isSome_minKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5862-L5867">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">kme</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkme</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">kme</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">kme</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_le_minKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5869-L5876">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_le_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_le_minKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">km </span><span class="fn">kme</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkme</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">kme</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">kme</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5878-L5885">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> (<span class="fn">e</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a>
    <span class="fn">(match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">w</span></span> =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">w</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">w</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5887-L5916">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a>
    <span class="fn">(match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">e</span></span> =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">e</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5918-L5923">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_insertIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5925-L5928">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_insertIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_insertIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5930-L5933">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntryIfNew_le_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5935-L5940">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntryIfNew_le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew_le_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">kmi</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntryIfNew_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5942-L5953">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">kmi</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_head?_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5955-L5958">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_head?_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_head?_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.head?">head?</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5960-L5965">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5967-L5983">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L5989-L6007">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">km</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">km</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">km</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey?_modifyKey_eq_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6009-L6016">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey?_modifyKey_eq_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey_eq_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_minKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6018-L6021">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_minKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_minKey?_modifyKey_eq_isSome"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6023-L6026">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_minKey?_modifyKey_eq_isSome"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_minKey?_modifyKey_eq_isSome</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey?_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6028-L6038">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey?_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmm</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmm</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">kmm</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey?_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6040-L6057">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6061-L6063">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">xs</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Given a proof that the list is nonempty, returns the smallest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">Std.Internal.List.minKey</a> <span class="fn">xs</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.minKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6065-L6068">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">hl</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_get_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6070-L6073">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_get_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_get_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6075-L6078">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6080-L6084">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6086-L6089">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6091-L6095">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntry_le_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6097-L6101">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntry_le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry_le_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntry_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6103-L6107">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6109-L6112">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6114-L6117">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6119-L6123">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6125-L6128">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6130-L6133">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6135-L6138">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6140-L6143">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eraseKey_eq_iff_beq_minKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6145-L6157">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eraseKey_eq_iff_beq_minKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eraseKey_eq_of_beq_minKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6159-L6164">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eraseKey_eq_of_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eraseKey_eq_of_beq_minKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_le_minKey_erase"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6166-L6170">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_le_minKey_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_le_minKey_erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6172-L6176">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntryIfNew_le_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6178-L6182">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntryIfNew_le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew_le_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntryIfNew_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6184-L6187">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_head_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6189-L6193">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_head_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_head_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.head">head</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6195-L6198">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6200-L6204">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6210-L6217">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey_modifyKey_eq_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6219-L6222">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey_modifyKey_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey_eq_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6224-L6227">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6229-L6233">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6237-L6239">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Returns the smallest key in an associative list or panics if the list is empty.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">Std.Internal.List.minKey!</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minKey!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.minKey!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6241-L6244">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_get!_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6246-L6249">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_get!_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_get!_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6251-L6254">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6256-L6259">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6261-L6264">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6266-L6269">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6271-L6275">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6277-L6281">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntry_le_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6283-L6286">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntry_le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry_le_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntry_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6288-L6291">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6293-L6296">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6298-L6301">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6303-L6306">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6308-L6311">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6313-L6316">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKey!_eq_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6318-L6321">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKey!_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey!_eq_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6323-L6326">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6328-L6331">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6333-L6337">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_iff_beq_minKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey!_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6339-L6343">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_iff_beq_minKey!_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eraseKey_eq_of_beq_minKey!_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6345-L6349">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eraseKey_eq_of_beq_minKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_of_beq_minKey!_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">heq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_le_minKey!_erase"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6351-L6354">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_le_minKey!_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_le_minKey!_erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6356-L6360">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntryIfNew_le_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6362-L6365">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntryIfNew_le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew_le_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntryIfNew_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6367-L6370">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_head!_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6372-L6378">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_head!_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_head!_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/BasicAux.html#List.head!">head!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6380-L6387">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6389-L6394">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6400-L6403">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey!_modifyKey_eq_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6405-L6412">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey!_modifyKey_eq_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey_eq_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey!_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6414-L6421">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey!_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey!_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6423-L6427">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6431-L6433">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Returns the smallest key in an associative list or <code>fallback</code> if the list is empty.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">Std.Internal.List.minKeyD</a> <span class="fn">xs</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minKeyD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.minKeyD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6435-L6438">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_getD_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6440-L6443">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_getD_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_getD_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6445-L6448">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6450-L6453">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_minKeyD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6455-L6458">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_minKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_minKeyD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6460-L6463">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6465-L6470">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6472-L6477">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6479-L6483">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntry_le_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6485-L6488">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntry_le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry_le_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntry_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6490-L6493">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6495-L6498">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6500-L6503">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6505-L6508">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6510-L6513">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6515-L6519">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKeyD_eq_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6521-L6525">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKeyD_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKeyD_eq_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6527-L6530">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6532-L6535">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">fallback'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">fallback'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6537-L6543">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_iff_beq_minKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6545-L6551">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6553-L6558">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">heq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_le_minKeyD_erase"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6560-L6565">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_le_minKeyD_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_le_minKeyD_erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6567-L6571">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntryIfNew_le_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6573-L6577">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntryIfNew_le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew_le_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntryIfNew_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6579-L6582">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_headD_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6584-L6587">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_headD_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_headD_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.headD">headD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6589-L6596">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6598-L6603">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6609-L6613">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKeyD_modifyKey_eq_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6615-L6622">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKeyD_modifyKey_eq_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey_eq_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKeyD_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6624-L6631">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKeyD_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKeyD_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6633-L6638">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6646-L6649">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></div></div><p>Returns the largest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">Std.Internal.List.maxKey?</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.maxKey?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6651-L6655">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6657-L6661">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6663-L6667">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_none_iff_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6669-L6672">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_none_iff_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_of_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6674-L6677">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_of_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_of_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.isNone_maxKey?_eq_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6679-L6682">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isNone_maxKey?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_maxKey?_eq_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_eq_not_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6684-L6687">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_eq_not_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_iff_isEmpty_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6689-L6692">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_iff_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_iff_isEmpty_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6694-L6699">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6701-L6705">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6707-L6711">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6713-L6717">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6719-L6723">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">km</span> <span class="fn">l</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6725-L6729">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6731-L6735">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">km</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_bind_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6737-L6741">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_bind_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_bind_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">k</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6743-L6747">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6749-L6753">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ {<span class="fn">km</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> → (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6755-L6760">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn">∀ {<span class="fn">km</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> → (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_le_maxKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6762-L6767">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_le_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_maxKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">kmi</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6769-L6774">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">kmi</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6776-L6781">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6783-L6788">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_of_isSome_maxKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6790-L6794">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_of_isSome_maxKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_of_isSome_maxKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6796-L6801">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">kme</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkme</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">kme</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">kme</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eraseKey_le_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6803-L6810">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eraseKey_le_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_le_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">km </span><span class="fn">kme</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkme</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">kme</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">kme</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6812-L6817">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6819-L6823">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_le_maxKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6825-L6830">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_le_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_maxKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">kmi</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6832-L6837">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">kmi</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.reverse_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6839-L6841">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.reverse_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">reverse_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_getLast?_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6843-L6849">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_getLast?_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_getLast?_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.getLast?">getLast?</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6851-L6855">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6857-L6862">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6868-L6872">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">km</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">km</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">km</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey?_modifyKey_eq_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6874-L6878">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey?_modifyKey_eq_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey_eq_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_maxKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6880-L6884">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_maxKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_maxKey?_modifyKey_eq_isSome"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6886-L6890">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_maxKey?_modifyKey_eq_isSome"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_maxKey?_modifyKey_eq_isSome</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey?_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6892-L6898">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey?_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmm</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmm</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">kmm</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey?_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6900-L6905">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6909-L6911">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">xs</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Given a proof that the list is nonempty, returns the largest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">Std.Internal.List.maxKey</a> <span class="fn">xs</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">Std.Internal.List.minKey</a> <span class="fn">xs</span> <span class="fn">h</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.maxKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.maxKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6913-L6917">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">hl</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_get_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6919-L6922">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_get_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_get_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6924-L6928">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6930-L6934">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6936-L6940">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6942-L6947">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_le_maxKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6949-L6953">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_le_maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le_maxKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6955-L6959">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6961-L6965">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_maxKey_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6967-L6971">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_maxKey_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKey_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6973-L6977">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6979-L6983">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6985-L6989">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6991-L6995">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L6997-L7001">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eraseKey_eq_iff_beq_maxKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7003-L7009">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eraseKey_eq_of_beq_maxKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7011-L7017">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eraseKey_eq_of_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_eq_of_beq_maxKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eraseKey_le_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7019-L7024">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eraseKey_le_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_le_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7026-L7031">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_le_maxKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7033-L7038">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_le_maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le_maxKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7040-L7044">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_getLast_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7046-L7052">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_getLast_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_getLast_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.getLast">getLast</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7054-L7058">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7060-L7065">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7071-L7079">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey_modifyKey_eq_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7081-L7085">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey_modifyKey_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey_eq_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7087-L7091">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7093-L7098">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7102-L7104">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Given a proof that the list is nonempty, returns the smallest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">Std.Internal.List.maxKey!</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">Std.Internal.List.maxKey?</a> <span class="fn">xs</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.maxKey!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.maxKey!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7106-L7110">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_get!_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7112-L7116">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_get!_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_get!_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7118-L7122">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7124-L7128">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7130-L7134">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7136-L7140">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7142-L7147">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7149-L7154">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_le_maxKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7156-L7160">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_le_maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le_maxKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7162-L7166">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7168-L7172">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_maxKey!_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7174-L7178">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_maxKey!_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKey!_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7180-L7184">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7186-L7190">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7192-L7196">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKey!_eq_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7198-L7202">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKey!_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey!_eq_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7204-L7208">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7210-L7214">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7216-L7221">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7223-L7228">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7230-L7235">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">heq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_erase_le_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7237-L7241">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_erase_le_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_erase_le_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7243-L7248">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_le_maxKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7250-L7254">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_le_maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le_maxKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7256-L7260">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_getLast!_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7262-L7267">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_getLast!_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_getLast!_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/BasicAux.html#List.getLast!">getLast!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7269-L7273">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7275-L7281">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7287-L7291">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey!_modifyKey_eq_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7293-L7297">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey!_modifyKey_eq_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey_eq_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey!_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7299-L7303">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey!_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey!_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7305-L7310">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7314-L7316">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Returns the smallest key in an associative list or <code>fallback</code> if the list is empty.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">Std.Internal.List.maxKeyD</a> <span class="fn">xs</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">Std.Internal.List.minKeyD</a> <span class="fn">xs</span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.maxKeyD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.maxKeyD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7318-L7322">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_getD_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7324-L7328">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_getD_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_getD_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7330-L7334">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7336-L7340">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_maxKeyD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7342-L7346">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_maxKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_maxKeyD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7348-L7352">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7354-L7359">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7361-L7366">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7368-L7373">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_le_maxKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7375-L7379">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_le_maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le_maxKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7381-L7385">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7387-L7391">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_maxKeyD_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7393-L7397">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_maxKeyD_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKeyD_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7399-L7403">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7405-L7409">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7411-L7415">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKeyD_eq_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7417-L7421">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKeyD_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKeyD_eq_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7423-L7427">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7429-L7433">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">fallback'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">fallback'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7435-L7441">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7443-L7449">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7451-L7456">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">heq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eraseKey_le_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7458-L7463">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eraseKey_le_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_le_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7465-L7470">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_le_maxKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7472-L7476">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_le_maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le_maxKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7478-L7482">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_getLastD_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7484-L7489">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_getLastD_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_getLastD_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.getLastD">getLastD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7491-L7495">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7497-L7503">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7509-L7514">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKeyD_modifyKey_eq_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7516-L7520">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKeyD_modifyKey_eq_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey_eq_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKeyD_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7522-L7526">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKeyD_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKeyD_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Std/Data/Internal/List/Associative.lean#L7528-L7534">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>