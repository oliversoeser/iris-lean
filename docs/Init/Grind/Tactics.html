<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Init.Grind.Tactics</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Init.Grind.Tactics";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Init</span>.<span class="name">Grind</span>.<span class="name">Tactics</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init/Tactics.html">Init.Tactics</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Grind.Tactics" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Grind.genPattern"><span class="name">Lean</span>.<span class="name">Grind</span>.<span class="name">genPattern</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Grind.genHEqPattern"><span class="name">Lean</span>.<span class="name">Grind</span>.<span class="name">genHEqPattern</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.resetGrindAttrs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">resetGrindAttrs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindGen"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindGen</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindEq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindEqBoth"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEqBoth</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindEqRhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEqRhs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindEqBwd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEqBwd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindBwd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindBwd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindFwd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindFwd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindRL"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindRL</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindLR"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindLR</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindUsr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindUsr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindCases"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindCases</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindCasesEager"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindCasesEager</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindIntro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindIntro</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindExt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindExt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindMod"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindMod</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grind?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Grind.Config"><span class="name">Lean</span>.<span class="name">Grind</span>.<span class="name">Config</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Grind.instInhabitedConfig"><span class="name">Lean</span>.<span class="name">Grind</span>.<span class="name">instInhabitedConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Grind.instBEqConfig"><span class="name">Lean</span>.<span class="name">Grind</span>.<span class="name">instBEqConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.grindErase"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">grindErase</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.grindLemma"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">grindLemma</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.grindParam"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">grindParam</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.grind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">grind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.grindTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">grindTrace</span></a></div></nav><main>
<div class="decl" id="Lean.Grind.genPattern"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L12-L56">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Grind.genPattern"><span class="name">Lean</span>.<span class="name">Grind</span>.<span class="name">genPattern</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">_h</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">_val</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Gadget for representing generalization steps <code>h : x = val</code> in patterns
This gadget is used to represent patterns in theorems that have been generalized to reduce the
number of casts introduced during E-matching based instantiation.</p><p>For example, consider the theorem</p><pre><code><a href="../.././Init/Data/Option/Lemmas.html#Option.pbind_some">Option.pbind_some</a> {α1 : Type u_1} {a : α1} {α2 : Type u_2}
    {f : (a_1 : α1) → some a = some a_1 → <a href="../.././Init/Prelude.html#Option">Option</a> α2}
    : (some a).pbind f = f a <a href="../.././Init/Prelude.html#rfl">rfl</a>
</code></pre><p>Now, suppose we have a goal containing the term <code>c.pbind g</code> and the equivalence class
<code>{c, some b}</code>. The E-matching module generates the instance</p><pre><code>(some b).pbind (cast ⋯ g)
</code></pre><p>The <code><a href="../.././Init/Prelude.html#cast">cast</a></code> is necessary because <code>g</code>'s type contains <code>c</code> instead of <code>some b. This </code>cast` problematic because we don't have a systematic way of pushing casts over functions
to its arguments. Moreover, heterogeneous equality is not effective because the following theorem
is not provable in DTT:</p><pre><code>theorem hcongr (h₁ : f ≍ g) (h₂ : a ≍ b)  : f a ≍ g b := ...
</code></pre><p>The standard solution is to generalize the theorem above and write it as</p><pre><code>theorem <a href="../.././Init/Data/Option/Lemmas.html#Option.pbind_some'">Option.pbind_some'</a>
        {α1 : Type u_1} {a : α1} {α2 : Type u_2}
        {x : <a href="../.././Init/Prelude.html#Option">Option</a> α1}
        {f : (a_1 : α1) → x = some a_1 → <a href="../.././Init/Prelude.html#Option">Option</a> α2}
        (h : x = some a)
        : x.pbind f = f a h := by
  subst h
  apply <a href="../.././Init/Data/Option/Lemmas.html#Option.pbind_some">Option.pbind_some</a>
</code></pre><p>Internally, we use this gadget to mark the E-matching pattern as</p><pre><code>(genPattern h x (some a)).pbind f
</code></pre><p>This pattern is matched in the same way we match <code>(some a).pbind f</code>, but it saves the proof
for the actual term to the <code>some</code>-application in <code>f</code>, and the actual term in <code>x</code>.</p><p>In the example above, <code>c.pbind g</code> also matches the pattern <code>(genPattern h x (some a)).pbind f</code>,
and stores <code>c</code> in <code>x</code>, <code>b</code> in <code>a</code>, and the proof that <code>c = some b</code> in <code>h</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Init/Grind/Tactics.html#Lean.Grind.genPattern">Lean.Grind.genPattern</a> <span class="fn">_h</span> <span class="fn">x</span> <span class="fn">_val</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></li></ul></details><details id="instances-for-list-Lean.Grind.genPattern" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Grind.genHEqPattern"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L58-L59">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Grind.genHEqPattern"><span class="name">Lean</span>.<span class="name">Grind</span>.<span class="name">genHEqPattern</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">_h</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">_val</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Similar to <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.genPattern">genPattern</a></code> but for the heterogenous case</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Init/Grind/Tactics.html#Lean.Grind.genHEqPattern">Lean.Grind.genHEqPattern</a> <span class="fn">_h</span> <span class="fn">x</span> <span class="fn">_val</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></li></ul></details><details id="instances-for-list-Lean.Grind.genHEqPattern" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.resetGrindAttrs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L63-L66">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.resetGrindAttrs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">resetGrindAttrs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Reset all <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> attributes. This command is intended for testing purposes only and should not be used in applications.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Tactics.html#Lean.Parser.resetGrindAttrs">Lean.Parser.resetGrindAttrs</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.resetGrindAttrs</span> <span class="fn">1024</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;reset_grind_attrs%&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.resetGrindAttrs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindGen"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L69-L69">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindGen"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindGen</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindGen">Lean.Parser.Attr.grindGen</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;grindGen&quot;</span> <span class="fn">`Lean.Parser.Attr.grindGen</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;gen &quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindGen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L70-L70">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindEq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindEqBoth"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L71-L71">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindEqBoth"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEqBoth</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindEqBoth" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindEqRhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L72-L72">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindEqRhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEqRhs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindEqRhs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindEqBwd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L73-L73">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindEqBwd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEqBwd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindEqBwd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindBwd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L74-L74">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindBwd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindBwd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindBwd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindFwd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L75-L75">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindFwd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindFwd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindFwd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindRL"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L76-L76">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindRL"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindRL</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindRL" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindLR"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L77-L77">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindLR"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindLR</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindLR" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindUsr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L78-L78">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindUsr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindUsr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindUsr">Lean.Parser.Attr.grindUsr</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;grindUsr&quot;</span> <span class="fn">`Lean.Parser.Attr.grindUsr</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;usr &quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindUsr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L79-L79">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindCases"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindCases</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindCases">Lean.Parser.Attr.grindCases</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;grindCases&quot;</span> <span class="fn">`Lean.Parser.Attr.grindCases</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;cases &quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindCasesEager"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L80-L80">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindCasesEager"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindCasesEager</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindCasesEager" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindIntro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L81-L81">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindIntro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindIntro</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindIntro">Lean.Parser.Attr.grindIntro</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;grindIntro&quot;</span> <span class="fn">`Lean.Parser.Attr.grindIntro</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;intro &quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindIntro" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindExt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L82-L82">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindExt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindExt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindExt">Lean.Parser.Attr.grindExt</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;grindExt&quot;</span> <span class="fn">`Lean.Parser.Attr.grindExt</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;ext &quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindExt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindMod"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L83-L86">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grindMod"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindMod</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindMod" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L87-L87">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grind?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L88-L88">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grind?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Grind.Config"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L93-L187">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Grind.Config"><span class="name">Lean</span>.<span class="name">Grind</span>.<span class="name">Config</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The configuration for <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code>.
Passed to <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> using, for example, the <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a> (config := { <a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.matchEqs">matchEqs</a> := true })</code> syntax.</p><ul class="structure_fields" id="Lean.Grind.Config.mk"><li id="Lean.Grind.Config.trace" class="structure_field"><div class="structure_field_info">trace : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.trace">trace</a></code> is <code>true</code>, <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> records used E-matching theorems and case-splits.</p></div></li><li id="Lean.Grind.Config.splits" class="structure_field"><div class="structure_field_info">splits : <a href="../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Maximum number of case-splits in a proof search branch. It does not include splits performed during normalization.</p></div></li><li id="Lean.Grind.Config.ematch" class="structure_field"><div class="structure_field_info">ematch : <a href="../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Maximum number of E-matching (aka heuristic theorem instantiation) rounds before each case split.</p></div></li><li id="Lean.Grind.Config.gen" class="structure_field"><div class="structure_field_info">gen : <a href="../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Maximum term generation.
The input goal terms have generation 0. When we instantiate a theorem using a term from generation <code>n</code>,
the new terms have generation <code>n+1</code>. Thus, this parameter limits the length of an instantiation chain.</p></div></li><li id="Lean.Grind.Config.instances" class="structure_field"><div class="structure_field_info">instances : <a href="../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Maximum number of theorem instances generated using E-matching in a proof search tree branch.</p></div></li><li id="Lean.Grind.Config.matchEqs" class="structure_field"><div class="structure_field_info">matchEqs : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.matchEqs">matchEqs</a></code> is <code>true</code>, <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> uses <code>match</code>-equations as E-matching theorems.</p></div></li><li id="Lean.Grind.Config.splitMatch" class="structure_field"><div class="structure_field_info">splitMatch : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.splitMatch">splitMatch</a></code> is <code>true</code>, <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> performs case-splitting on <code>match</code>-expressions during the search.</p></div></li><li id="Lean.Grind.Config.splitIte" class="structure_field"><div class="structure_field_info">splitIte : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.splitIte">splitIte</a></code> is <code>true</code>, <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> performs case-splitting on <code>if-then-else</code> expressions during the search.</p></div></li><li id="Lean.Grind.Config.splitIndPred" class="structure_field"><div class="structure_field_info">splitIndPred : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.splitIndPred">splitIndPred</a></code> is <code>true</code>, <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> performs case-splitting on inductive predicates.
Otherwise, it performs case-splitting only on types marked with <code>[grind cases]</code> attribute.</p></div></li><li id="Lean.Grind.Config.splitImp" class="structure_field"><div class="structure_field_info">splitImp : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.splitImp">splitImp</a></code> is <code>true</code>, then given an implication <code>p → q</code> or <code>(h : p) → q h</code>, <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> splits on <code>p</code>
if the implication is true. Otherwise, it will split only if <code>p</code> is an arithmetic predicate.</p></div></li><li id="Lean.Grind.Config.canonHeartbeats" class="structure_field"><div class="structure_field_info">canonHeartbeats : <a href="../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Maximum number of heartbeats (in thousands) the canonicalizer can spend per definitional equality test.</p></div></li><li id="Lean.Grind.Config.ext" class="structure_field"><div class="structure_field_info">ext : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.ext">ext</a></code> is <code>true</code>, <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> uses extensionality theorems that have been marked with <code>[grind ext]</code>.</p></div></li><li id="Lean.Grind.Config.extAll" class="structure_field"><div class="structure_field_info">extAll : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.extAll">extAll</a></code> is <code>true</code>, <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> uses any extensionality theorems available in the environment.</p></div></li><li id="Lean.Grind.Config.etaStruct" class="structure_field"><div class="structure_field_info">etaStruct : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.etaStruct">etaStruct</a></code> is <code>true</code>, then for each term <code>t : S</code> such that <code>S</code> is a structure,
and is tagged with <code>[grind ext]</code>, <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> adds the equation <code>t = ⟨t.1, ..., t.n⟩</code>
which holds by reflexivity. Moreover, the extensionality theorem for <code>S</code> is not used.</p></div></li><li id="Lean.Grind.Config.funext" class="structure_field"><div class="structure_field_info">funext : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../.././Init/Core.html#funext">funext</a></code> is <code>true</code>, <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> creates new opportunities for applying function extensionality by case-splitting
on equalities between lambda expressions.</p></div></li><li id="Lean.Grind.Config.lookahead" class="structure_field"><div class="structure_field_info">lookahead : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>TODO</p></div></li><li id="Lean.Grind.Config.verbose" class="structure_field"><div class="structure_field_info">verbose : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.verbose">verbose</a></code> is <code>false</code>, additional diagnostics information is not collected.</p></div></li><li id="Lean.Grind.Config.clean" class="structure_field"><div class="structure_field_info">clean : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.clean">clean</a></code> is <code>true</code>, <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> uses <code>expose_names</code> and only generates accessible names.</p></div></li><li id="Lean.Grind.Config.qlia" class="structure_field"><div class="structure_field_info">qlia : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.qlia">qlia</a></code> is <code>true</code>, <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> may generate counterexamples for integer constraints
using rational numbers, and ignoring divisibility constraints.
This approach is cheaper but incomplete.</p></div></li><li id="Lean.Grind.Config.mbtc" class="structure_field"><div class="structure_field_info">mbtc : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.mbtc">mbtc</a></code> is <code>true</code>, <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> will use model-based theory combination for creating new case splits.
See paper &quot;Model-based Theory Combination&quot; for details.</p></div></li><li id="Lean.Grind.Config.zetaDelta" class="structure_field"><div class="structure_field_info">zetaDelta : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>When set to <code>true</code> (default: <code>true</code>), local definitions are unfolded during normalization and internalization.
In other words, given a local context with an entry <code>x : t := e</code>, the free variable <code>x</code> is reduced to <code>e</code>.
Note that this behavior is also available in <code>simp</code>, but there its default is <code>false</code> because <code>simp</code> is not
always used as a terminal tactic, and it important to preserve the abstractions introduced by users.
Additionally, in <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> we observed that <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.zetaDelta">zetaDelta</a></code> is particularly important when combined with function induction.
In such scenarios, the same let-expressions can be introduced by function induction and also by unfolding the
corresponding definition. We want to avoid a situation in which <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.zetaDelta">zetaDelta</a></code> is not applied to let-declarations
introduced by function induction while <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.zeta">zeta</a></code> unfolds the definition, causing a mismatch.
Finally, note that congruence closure is less effective on terms containing many binders such as
<code>lambda</code> and <code>let</code> expressions.</p></div></li><li id="Lean.Grind.Config.zeta" class="structure_field"><div class="structure_field_info">zeta : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>When <code>true</code> (default: <code>true</code>), performs zeta reduction of let expressions during normalization.
That is, <code>let x := v; e[x]</code> reduces to <code>e[v]</code>. See also <code><a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config.zetaDelta">zetaDelta</a></code>.</p></div></li><li id="Lean.Grind.Config.ring" class="structure_field"><div class="structure_field_info">ring : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>When <code>true</code> (default: <code>false</code>), uses procedure for handling equalities over commutative rings.</p></div></li><li id="Lean.Grind.Config.ringSteps" class="structure_field"><div class="structure_field_info">ringSteps : <a href="../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Grind.Config.ringNull" class="structure_field"><div class="structure_field_info">ringNull : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>When <code>true</code> (default: <code>false</code>), the commutative ring procedure in <code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> constructs stepwise
proof terms, instead of a single-step Nullstellensatz certificate</p></div></li></ul><details id="instances-for-list-Lean.Grind.Config" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Grind.instInhabitedConfig"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L187-L187">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Grind.instInhabitedConfig"><span class="name">Lean</span>.<span class="name">Grind</span>.<span class="name">instInhabitedConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config">Config</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Grind.instBEqConfig"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L187-L187">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Grind.instBEqConfig"><span class="name">Lean</span>.<span class="name">Grind</span>.<span class="name">instBEqConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <a href="../.././Init/Grind/Tactics.html#Lean.Grind.Config">Config</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Tactics.html#Lean.Grind.instBEqConfig">Lean.Grind.instBEqConfig</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <a href="../.././Init/Grind/Tactics.html#Lean.Grind.beqConfig._@.Init.Grind.Tactics._hyg.488">Lean.Grind.beqConfig✝</a> <a href="../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="mod_doc"><p><code><a href="../.././Init/Grind/Tactics.html#Lean.Parser.Attr.grind">grind</a></code> tactic and related tactics.</p></div><div class="decl" id="Lean.Parser.Tactic.grindErase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L197-L197">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Tactic.grindErase"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">grindErase</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.grindErase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.grindLemma"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L198-L198">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Tactic.grindLemma"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">grindLemma</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.grindLemma" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.grindParam"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L199-L199">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Tactic.grindParam"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">grindParam</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.grindParam" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.grind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L201-L204">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Tactic.grind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">grind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.grind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.grindTrace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/Grind/Tactics.lean#L207-L210">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Tactics.html#Lean.Parser.Tactic.grindTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">grindTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.grindTrace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>